using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Unity.Netcode
{
    enum SceneEventType
    {
        Idle,
        SvrSceneLoad,//服务端事件
        SvrSceneUnload,//服务端事件
        ClientSceneLoad,//客户端事件
        ObjectSceneChanged//客户端事件
    }

    internal class SceneEventData : IDisposable
    {
        internal SceneEventType seType;//事件类型
        internal ulong targetClientId;//目标客户端id
        internal string sceneName;//场景名称
        internal ushort sceneObjectCount;//场景对象计数
        internal List<NetworkObject.SceneObject> sceneObjects;//场景对象列表
        internal ushort enterObjectCount;//进入场景的对象数
        internal ushort leaveObjectCount;//离开场景的对象数
        internal Queue<NetworkObject.SceneObject> enterQue;
        internal Queue<NetworkObject.SceneObject> leaveQue;

        internal void Serialize(FastBufferWriter writer)
        {
            writer.WriteValueSafe(seType);
            writer.WriteValueSafe(targetClientId);
            if (seType == SceneEventType.ClientSceneLoad)
            {
                writer.WriteValueSafe(sceneName);
                SerializeScenePlacedObjects(writer);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                writer.WriteValueSafe(enterObjectCount);
                foreach (var obj in enterQue)
                {
                    obj.Serialize(writer);
                }
                writer.WriteValueSafe(leaveObjectCount);
                foreach (var obj in leaveQue)
                {
                    obj.Serialize(writer);
                }
            }
        }

        internal void Deserialize(FastBufferReader reader)
        {
            reader.ReadValueSafe(out seType);
            reader.ReadValueSafe(out targetClientId);
            if (seType == SceneEventType.ClientSceneLoad)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ClientSceneLoad;
                reader.ReadValueSafe(out sceneName);
                DeserializeScenePlacedObjects(reader);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ObjectSceneChanged;
                reader.ReadValueSafe(out enterObjectCount);
                enterQue = new Queue<NetworkObject.SceneObject>();
                for (int i = 0; i < enterObjectCount; i++)
                {
                    NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                    obj.Deserialize(reader);
                    enterQue.Enqueue(obj);
                }
                reader.ReadValueSafe(out leaveObjectCount);
                leaveQue = new Queue<NetworkObject.SceneObject>();
                for (int i = 0; i < leaveObjectCount; i++)
                {
                    NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                    obj.Deserialize(reader);
                    leaveQue.Enqueue(obj);
                }
                if(NetworkManager.Singleton.SceneManager.m_curSceneEvent== SceneEventType.ObjectSceneChanged)
                    NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.Idle;
            }
        }

        internal void SerializeScenePlacedObjects(FastBufferWriter writer)
        {
            var numberOfObjects = (ushort)0;
            var headPosition = writer.Position;
            writer.WriteValueSafe((ushort)0);

            ushort count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return;

            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (var go in gameObjects)
            {
                NetworkObject[] objs = go.GetComponentsInChildren<NetworkObject>(true);
                foreach (var netobj in objs)
                {
                    if (!netobj.IsPlayerObject&&(netobj.IsSceneObject==null|| netobj.IsSceneObject ==true))
                    {
                        NetworkObject.SceneObject scobj = netobj.GetMessageSceneObject(targetClientId);
                        scobj.Serialize(writer);
                        count++;
                    }
                }
            }
            var tailPosition = writer.Position;
            writer.Seek(headPosition);
            writer.WriteValueSafe(count);
            writer.Seek(tailPosition);

            return;
        }

        internal void DeserializeScenePlacedObjects(FastBufferReader reader)
        {
            reader.ReadValueSafe(out sceneObjectCount);
            sceneObjects = new List<NetworkObject.SceneObject>();

            for (int i=0;i< sceneObjectCount;i++)
            {
                NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                obj.Deserialize(reader);
                sceneObjects.Add(obj);               
            }
        }

        public void Dispose()
        {
        }
    }

    public class NetworkSceneManager : INetworkSceneManager, IDisposable
    {
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的CreateLocalNetworkObject函数里被使用，决定了Spawn的游戏对象是否在DDOL。
        /// </summary>
        internal  static bool  IsSpawnedObjectsPendingInDontDestroyOnLoad;
        /// <summary>
        /// 这个参数在NetworkObject里的SceneChangedUpdate里被调用，用于将客户端场景句柄转换为服务端场景句柄
        /// </summary>
        internal Dictionary<int, int> ClientSceneHandleToServerSceneHandle = new Dictionary<int, int>();
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的ServerDestroySpawnedSceneObjects里被调用
        /// </summary>
        internal Scene DontDestroyOnLoadScene;

        private NetworkManager m_networkManager;

        private SceneEventData m_SceneEventData;

        internal SceneEventType m_curSceneEvent;//当前场景事件，如果为idle则合适处理一些事情(注意：服务端和客户端具备不同的事件)

        internal Dictionary<ulong, string> m_ClientScenes = new Dictionary<ulong, string>();//每个客户端的当前场景
        
        internal struct SceneChangeItem
        {
            internal int sceneHandle;
            internal string sceneName;
            internal Queue<NetworkObject.SceneObject> enterQue;
            internal Queue<NetworkObject.SceneObject> leaveQue;
        }
        
        internal Dictionary<int, SceneChangeItem> m_ObjectChangeScene = new Dictionary<int, SceneChangeItem>();//每个场景的
        internal Dictionary<int, string> m_SceneHandleToName = new Dictionary<int, string>();//场景句柄到场景名称的映射
        /// <summary>
        /// 缺省的场景
        /// </summary>
        private string m_DefaultScene;

        internal struct ServerSceneEvent
        {
            internal bool IsForLoad;
            internal string sceneName;
        }

        private Queue<ServerSceneEvent> m_sceneEvent=new Queue<ServerSceneEvent>();
        private string m_curLoadScene;
        private string m_curUnloadScene;

        internal NetworkSceneManager(NetworkManager networkManager)
        {
            m_networkManager = networkManager;
            m_curSceneEvent = SceneEventType.Idle;
            m_networkManager.OnClientDisconnectCallback += OnDisconnect;
            m_networkManager.OnClientConnectedCallback += OnConnect;
        }

        internal void OnDisconnect(ulong id)
        {
            m_ClientScenes.Remove(id);
            Debug.LogFormat("Disconnect {0}", id);
        }

        internal void OnConnect(ulong id)
        {
            m_ClientScenes.Add(id, m_DefaultScene);
            Debug.LogFormat("Connect {0}", id);
        }
        /// <summary>
        /// 这个函数在NetworkObject里的SceneChangedUpdate函数里被调用
        /// </summary>
        /// <param name="networkObject"></param>
        internal void NotifyNetworkObjectSceneChanged(NetworkObject networkObject)
        {

        }

        /// <summary>
        /// 这个函数在NetworkManager的NetworkUpdateStage.PostLateUpdate状态下被调用
        /// </summary>
        internal void CheckForAndSendNetworkObjectSceneChanged()
        {
            if (NetworkManager.Singleton.IsServer)
            {
                //向客户端发送活动对象进出场景事件

            }
            else
            {
                if (m_curSceneEvent != SceneEventType.Idle) return;//如果当前忙则不做处理
                //处理接收到的活动对象进出场景事件

            }
        }

        /// <summary>
        /// 这个函数在NetworkSpawnManager里的HasPrefab里被调用
        /// 这个函数在NetworkSpawnManager里的CreateLocalNetworkObject里被调用
        /// </summary>
        /// <param name="globalObjectIdHash"></param>
        /// <param name="networkSceneHandle"></param>
        /// <returns></returns>
        internal NetworkObject GetSceneRelativeInSceneNetworkObject(uint globalObjectIdHash, int? networkSceneHandle)
        {
            foreach (NetworkObject no in GameObject.FindObjectsOfType<NetworkObject>())
            {
                if (no.GlobalObjectIdHash == globalObjectIdHash)
                {
                    return no;
                }
            }
            return null;
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <param name="senderId"></param>
        /// <param name="messageSize"></param>
        /// <param name="sceneObject"></param>
        /// <param name="fastBufferReader"></param>
        internal void DeferCreateObject(ulong senderId, uint messageSize, NetworkObject.SceneObject sceneObject, FastBufferReader fastBufferReader)
        {

        }

        /// <summary>
        /// 这个函数在NetworkCoonnectionManager的HandleConnectionApproval函数里被调用
        /// </summary>
        /// <param name="clientId"></param>
        internal void SynchronizeNetworkObjects(ulong clientId)
        {
            if (!m_networkManager.ConnectedClients[clientId].IsConnected)
            {
                m_networkManager.ConnectedClients[clientId].IsConnected = true;
                m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(clientId);
            }

            SceneEventData seData = new SceneEventData();
            seData.seType = SceneEventType.ClientSceneLoad;
            seData.targetClientId = clientId;
            seData.sceneName = m_ClientScenes[clientId];
            var message = new SceneEventMessage
            {
                EventData = seData
            };
            m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <returns></returns>
        internal bool ShouldDeferCreateObject()
        {
            return false;
        }

        /// <summary>
        /// 客户端网络消息处理函数
        /// </summary>
        /// <param name="seData"></param>
        internal void HandleSceneEvent(SceneEventData seData)
        {
            if (m_networkManager.IsServer)
            {

            }
            else
            {
                if (seData.seType == SceneEventType.ClientSceneLoad)
                {
                    if (!m_networkManager.IsConnectedClient)
                    {
                        m_networkManager.IsConnectedClient = true;
                        m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(m_networkManager.LocalClientId);
                    }
                    IsSpawnedObjectsPendingInDontDestroyOnLoad = true;
                    m_SceneEventData = seData;
                    m_curLoadScene = seData.sceneName;
                    AsyncOperation op = SceneManager.LoadSceneAsync(m_curLoadScene, LoadSceneMode.Single);
                    op.completed += OnClientSceneLoadComplete;
                }
            }
        }

        private void OnClientSceneLoadComplete(AsyncOperation op)
        {
            for(int i = 0; i< m_SceneEventData.sceneObjectCount; i++)
            {
                var networkObject = NetworkManager.Singleton.SpawnManager.CreateLocalNetworkObject(m_SceneEventData.sceneObjects[i]);
                if (networkObject != null)
                {
                    m_networkManager.SpawnManager.SpawnNetworkObjectLocally(networkObject, m_SceneEventData.sceneObjects[i], true);
                    networkObject.InternalInSceneNetworkObjectsSpawned();
                }
            }
            Scene sc = SceneManager.GetSceneByName(m_curLoadScene);
            MoveObjectsFromDontDestroyOnLoadToScene(sc);
            IsSpawnedObjectsPendingInDontDestroyOnLoad = false;

            if (m_curSceneEvent== SceneEventType.ClientSceneLoad)
                m_curSceneEvent = SceneEventType.Idle;
        }

        internal void MoveObjectsFromDontDestroyOnLoadToScene(Scene scene)
        {
            foreach (var networkObject in m_networkManager.SpawnManager.SpawnedObjectsList)
            {
                if (networkObject == null)
                {
                    continue;
                }
                // If it is in the DDOL then
                if (networkObject.gameObject.scene == DontDestroyOnLoadScene && !networkObject.DestroyWithScene)
                {
                    // only move dynamically spawned network objects, with no parent as child objects will follow,
                    // back into the currently active scene
                    if (networkObject.gameObject.transform.parent == null && networkObject.IsSceneObject != null && !networkObject.IsSceneObject.Value)
                    {
                        SceneManager.MoveGameObjectToScene(networkObject.gameObject, scene);
                    }
                }
            }
        }

        public void Dispose()
        {
            m_networkManager.OnClientDisconnectCallback -= OnDisconnect;
            m_networkManager.OnClientConnectedCallback -= OnConnect;
        }

        public bool IsIdle()
        {
            return (m_curSceneEvent == SceneEventType.Idle && m_sceneEvent.Count == 0);
        }

        public void SvrLoadScene(string sceneName)
        {
            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.IsForLoad = true;
            ssEvent.sceneName = sceneName;
            m_sceneEvent.Enqueue(ssEvent);
            if (m_sceneEvent.Count > 1) return;
            ProcessServerSceneEvent();
        }

        public void SvrUnloadScene(string sceneName)
        {
            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.IsForLoad = false;
            ssEvent.sceneName = sceneName;
            m_sceneEvent.Enqueue(ssEvent);
            if (m_sceneEvent.Count > 1) return;
            ProcessServerSceneEvent();
        }

        public void SvrCreateAndMerageScene(string desScene, string srcScene, Vector3 offset)
        {

        }

        public void ClientSwitchScene(string curScene)
        {

        }

        public void SetDefaultScene(string defaultScene)
        {
            m_DefaultScene = defaultScene;
        }
        
        private void OnProcessServerSceneEventEnd()
        {
            //生成句柄和场景名称的映射字典
            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene sc = SceneManager.GetSceneAt(i);
                if (!m_SceneHandleToName.ContainsKey(sc.handle))
                    m_SceneHandleToName.Add(sc.handle, sc.name);
            }
        }

        private void ProcessServerSceneEvent()
        {
            if (m_sceneEvent.Count == 0)
            {
                m_curSceneEvent = SceneEventType.Idle;
                OnProcessServerSceneEventEnd();
                return;
            }

            if (m_curSceneEvent != SceneEventType.Idle)
                return;

            
            bool bFailed;
            do
            {
                ServerSceneEvent ssEvent = m_sceneEvent.Peek();
                bFailed = false;
                if (ssEvent.IsForLoad)
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneLoad;
                        m_curLoadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.LoadSceneAsync(ssEvent.sceneName, LoadSceneMode.Additive);
                        op.completed += OnSvrSceneLoadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("LoadScene {0} Exception caught: {1}", m_curLoadScene,e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
                else
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneUnload;
                        m_curLoadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.UnloadSceneAsync(ssEvent.sceneName, UnloadSceneOptions.None);
                        op.completed += OnSvrSceneUnloadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("UnloadScene {0} Exception caught: {1}", m_curLoadScene,e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
            } while (bFailed&& m_sceneEvent.Count>0);

           m_curSceneEvent = SceneEventType.Idle;
           OnProcessServerSceneEventEnd();
           return;
        }

        private void OnSvrSceneUnloadComplete(AsyncOperation op)
        {
            m_sceneEvent.Dequeue();

            Debug.LogFormat("Unload scene {0} Completed", m_curUnloadScene);
            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneEvent();
        }

        private void OnSvrSceneLoadComplete(AsyncOperation op)
        {
            m_sceneEvent.Dequeue();

            Debug.LogFormat("load scene {0} Completed", m_curLoadScene);
            int c = SvrSpawnSceneObjects(m_curLoadScene);
            Debug.LogFormat("spawn scene {0} Completed, {1} SceneObject Spawned", m_curLoadScene, c);
            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneEvent();
        }

        private int SvrSpawnSceneObjects(string sceneName)
        {
            int count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return count;
            
            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach(var go in gameObjects)
            {
                NetworkObject[] objs=go.GetComponentsInChildren<NetworkObject>(true);
                foreach( var netobj in objs)
                {
                    if (!netobj.IsPlayerObject && (netobj.IsSceneObject == null||netobj.IsSceneObject==true))
                    {
                        m_networkManager.SpawnManager.SpawnNetworkObjectLocally(netobj, m_networkManager.SpawnManager.GetNetworkObjectId(), true, false, NetworkManager.ServerClientId, true);
                        netobj.InternalInSceneNetworkObjectsSpawned();
                        count++;
                    }
                }
            }

            return count;
        }
    }
}
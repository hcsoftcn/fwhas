using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Unity.Netcode
{
    enum SceneEventType
    {
        None,
        ClientLoad
    }

    internal class SceneEventData : IDisposable
    {
        internal SceneEventType seType;
        internal ulong targetClientId;
        internal string sceneName;
        internal ushort sceneObjectCount;
        internal List<NetworkObject.SceneObject> sceneObjects;


        internal void Serialize(FastBufferWriter writer)
        {
            writer.WriteValueSafe(seType);
            writer.WriteValueSafe(targetClientId);
            writer.WriteValueSafe(sceneName);
            SerializeScenePlacedObjects(writer);
        }

        internal void Deserialize(FastBufferReader reader)
        {
            reader.ReadValueSafe(out seType);
            reader.ReadValueSafe(out targetClientId);
            reader.ReadValueSafe(out sceneName);
            DeserializeScenePlacedObjects(reader);
        }

        internal void SerializeScenePlacedObjects(FastBufferWriter writer)
        {
            var numberOfObjects = (ushort)0;
            var headPosition = writer.Position;
            writer.WriteValueSafe((ushort)0);

            ushort count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return;

            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (var go in gameObjects)
            {
                NetworkObject[] objs = go.GetComponentsInChildren<NetworkObject>(true);
                foreach (var netobj in objs)
                {
                    if (!netobj.IsPlayerObject&&(netobj.IsSceneObject==null|| netobj.IsSceneObject ==true))
                    {
                        //Debug.LogFormat("netobj IsSceneObject {0}", netobj.IsSceneObject);
                        NetworkObject.SceneObject scobj = netobj.GetMessageSceneObject(targetClientId);
                        //Debug.LogFormat("netobj.scobj IsSceneObject {0}", scobj.IsSceneObject); 
                        scobj.Serialize(writer);
                        count++;
                    }
                }
            }
            var tailPosition = writer.Position;
            writer.Seek(headPosition);
            writer.WriteValueSafe(count);
            writer.Seek(tailPosition);

            return;
        }

        internal void DeserializeScenePlacedObjects(FastBufferReader reader)
        {
            reader.ReadValueSafe(out sceneObjectCount);
            sceneObjects = new List<NetworkObject.SceneObject>();

            for (int i=0;i< sceneObjectCount;i++)
            {
                NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                obj.Deserialize(reader);
                //Debug.LogFormat("DeserializeScenePlacedObjects SceneObject {0}", obj.IsSceneObject);
                sceneObjects.Add(obj);               
            }
        }

        public void Dispose()
        {
        }
    }

    public class NetworkSceneManager : INetworkSceneManager, IDisposable
    {
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的CreateLocalNetworkObject函数里被使用，决定了Spawn的游戏对象是否在DDOL。
        /// </summary>
        internal  static bool  IsSpawnedObjectsPendingInDontDestroyOnLoad;
        /// <summary>
        /// 这个参数在NetworkObject里的SceneChangedUpdate里被调用，用于将客户端场景句柄转换为服务端场景句柄
        /// </summary>
        internal Dictionary<int, int> ClientSceneHandleToServerSceneHandle = new Dictionary<int, int>();
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的ServerDestroySpawnedSceneObjects里被调用
        /// </summary>
        internal Scene DontDestroyOnLoadScene;

        private NetworkManager m_networkManager;

        private SceneEventData m_SceneEventData;
        /// <summary>
        /// 缺省的场景
        /// </summary>
        private string m_DefaultScene;

        private Queue<string> m_scenesForLoad;
        private string m_curLoadScene;

        internal NetworkSceneManager(NetworkManager networkManager)
        {
            m_networkManager = networkManager;
        }

        /// <summary>
        /// 这个函数在NetworkObject里的SceneChangedUpdate函数里被调用
        /// </summary>
        /// <param name="networkObject"></param>
        internal void NotifyNetworkObjectSceneChanged(NetworkObject networkObject)
        {

        }

        /// <summary>
        /// 这个函数在NetworkSpawnManager里的HasPrefab里被调用
        /// 这个函数在NetworkSpawnManager里的CreateLocalNetworkObject里被调用
        /// </summary>
        /// <param name="globalObjectIdHash"></param>
        /// <param name="networkSceneHandle"></param>
        /// <returns></returns>
        internal NetworkObject GetSceneRelativeInSceneNetworkObject(uint globalObjectIdHash, int? networkSceneHandle)
        {
            foreach (NetworkObject no in GameObject.FindObjectsOfType<NetworkObject>())
            {
                if (no.GlobalObjectIdHash == globalObjectIdHash)
                {
                    return no;
                }
            }
            return null;
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <param name="senderId"></param>
        /// <param name="messageSize"></param>
        /// <param name="sceneObject"></param>
        /// <param name="fastBufferReader"></param>
        internal void DeferCreateObject(ulong senderId, uint messageSize, NetworkObject.SceneObject sceneObject, FastBufferReader fastBufferReader)
        {

        }

        /// <summary>
        /// 这个函数在NetworkCoonnectionManager的HandleConnectionApproval函数里被调用
        /// </summary>
        /// <param name="clientId"></param>
        internal void SynchronizeNetworkObjects(ulong clientId)
        {
            SceneEventData seData = new SceneEventData();
            seData.seType = SceneEventType.ClientLoad;
            seData.targetClientId = clientId;
            seData.sceneName = m_DefaultScene;
            var message = new SceneEventMessage
            {
                EventData = seData
            };
            NetworkManager.Singleton.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
            //Debug.LogFormat("SynchronizeNetworkObjects for clientId {0}", clientId);
        }

        /// <summary>
        /// 这个函数在NetworkManager的NetworkUpdateStage.PostLateUpdate状态下被调用
        /// </summary>
        internal void CheckForAndSendNetworkObjectSceneChanged()
        {

        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <returns></returns>
        internal bool ShouldDeferCreateObject()
        {
            return false;
        }

        /// <summary>
        /// 网络消息处理函数
        /// </summary>
        /// <param name="seData"></param>
        internal void HandleSceneEvent(SceneEventData seData)
        {
            if(seData.seType== SceneEventType.ClientLoad)
            {
                m_SceneEventData = seData;
                AsyncOperation op =SceneManager.LoadSceneAsync(seData.sceneName, LoadSceneMode.Single);
                op.completed += OnClientSceneLoadComplete;
            }
        }

        private void OnClientSceneLoadComplete(AsyncOperation op)
        {
            for(int i = 0; i< m_SceneEventData.sceneObjectCount; i++)
            {
                var networkObject = NetworkManager.Singleton.SpawnManager.CreateLocalNetworkObject(m_SceneEventData.sceneObjects[i]);
                if (networkObject != null)
                {
                    NetworkManager.Singleton.SpawnManager.SpawnNetworkObjectLocally(networkObject, m_SceneEventData.sceneObjects[i], true);
                    //Debug.LogFormat("Spawn networkObject {0} success", networkObject.NetworkObjectId);
                    networkObject.InternalInSceneNetworkObjectsSpawned();
                }
            }
        }

        public void Dispose()
        {
        }

        public AsyncOperation SvrLoadScene(string sceneName)
        {
            AsyncOperation op = SceneManager.LoadSceneAsync(sceneName,LoadSceneMode.Additive);
            return op;
        }

        public AsyncOperation SvrUnLoadScene(string sceneName)
        {
            return null;
        }

        public void SvrCreateAndMerageScene(string desScene, string srcScene, Vector3 offset)
        {

        }

        public void ClientSwitchScene(string curScene)
        {

        }

        public void SetDefaultScene(string defaultScene)
        {
            m_DefaultScene = defaultScene;
        }

        public void SvrLoadScenes(Queue<string> scenes)
        {
            if (scenes.Count==0) return;
            m_scenesForLoad = scenes;
            m_curLoadScene = m_scenesForLoad.Dequeue();
            AsyncOperation op = SvrLoadScene(m_curLoadScene);
            op.completed += OnSvrSceneLoadComplete;
        }

        private void OnSvrSceneLoadComplete(AsyncOperation op)
        {
            Debug.LogFormat("load scene {0} Completed", m_curLoadScene);
            int c=SvrSpawnSceneObjects(m_curLoadScene);
            Debug.LogFormat("spawn scene {0} Completed, {1} SceneObject Spawned", m_curLoadScene,c);
            if (m_scenesForLoad.Count == 0) return;
            m_curLoadScene = m_scenesForLoad.Dequeue();
            AsyncOperation op1 = SvrLoadScene(m_curLoadScene);
            op1.completed += OnSvrSceneLoadComplete;
        }

        private int SvrSpawnSceneObjects(string sceneName)
        {
            int count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return count;
            
            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach(var go in gameObjects)
            {
                NetworkObject[] objs=go.GetComponentsInChildren<NetworkObject>(true);
                foreach( var netobj in objs)
                {
                    if (!netobj.IsPlayerObject && (netobj.IsSceneObject == null||netobj.IsSceneObject==true))
                    {
                        NetworkManager.Singleton.SpawnManager.SpawnNetworkObjectLocally(netobj, NetworkManager.Singleton.SpawnManager.GetNetworkObjectId(), true, false, NetworkManager.ServerClientId, true);
                        netobj.InternalInSceneNetworkObjectsSpawned();
                        count++;
                    }
                }
            }

            return count;
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Unity.Netcode
{
    enum SceneEventType
    {
        Idle,
        ClientSceneLoad,
        ObjectSceneChanged
    }

    internal class SceneEventData : IDisposable
    {
        internal SceneEventType seType;//事件类型
        internal ulong targetClientId;//目标客户端id
        internal string sceneName;//场景名称
        internal ushort sceneObjectCount;//场景对象计数
        internal List<NetworkObject.SceneObject> sceneObjects;//场景对象列表
        internal ushort enterObjectCount;//进入场景的对象数
        internal List<NetworkObject.SceneObject> enterObjects;//进入场景的对象列表
        internal ushort leaveObjectCount;//离开场景的对象数
        internal List<NetworkObject.SceneObject> leaveObjects;//离开场景的对象列表

        internal void Serialize(FastBufferWriter writer)
        {
            writer.WriteValueSafe(seType);
            writer.WriteValueSafe(targetClientId);
            if (seType == SceneEventType.ClientSceneLoad)
            {
                writer.WriteValueSafe(sceneName);
                SerializeScenePlacedObjects(writer);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                writer.WriteValueSafe(enterObjectCount);
                foreach (var obj in enterObjects)
                {
                    obj.Serialize(writer);
                }
                writer.WriteValueSafe(leaveObjectCount);
                foreach (var obj in leaveObjects)
                {
                    obj.Serialize(writer);
                }
            }
        }

        internal void Deserialize(FastBufferReader reader)
        {
            reader.ReadValueSafe(out seType);
            reader.ReadValueSafe(out targetClientId);
            if (seType == SceneEventType.ClientSceneLoad)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ClientSceneLoad;
                reader.ReadValueSafe(out sceneName);
                DeserializeScenePlacedObjects(reader);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ObjectSceneChanged;
                reader.ReadValueSafe(out enterObjectCount);
                enterObjects = new List<NetworkObject.SceneObject>();
                for (int i = 0; i < enterObjectCount; i++)
                {
                    NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                    obj.Deserialize(reader);
                    enterObjects.Add(obj);
                }
                reader.ReadValueSafe(out leaveObjectCount);
                leaveObjects = new List<NetworkObject.SceneObject>();
                for (int i = 0; i < leaveObjectCount; i++)
                {
                    NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                    obj.Deserialize(reader);
                    leaveObjects.Add(obj);
                }
                if(NetworkManager.Singleton.SceneManager.m_curSceneEvent== SceneEventType.ObjectSceneChanged)
                    NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.Idle;
            }
        }

        internal void SerializeScenePlacedObjects(FastBufferWriter writer)
        {
            var numberOfObjects = (ushort)0;
            var headPosition = writer.Position;
            writer.WriteValueSafe((ushort)0);

            ushort count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return;

            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (var go in gameObjects)
            {
                NetworkObject[] objs = go.GetComponentsInChildren<NetworkObject>(true);
                foreach (var netobj in objs)
                {
                    if (!netobj.IsPlayerObject&&(netobj.IsSceneObject==null|| netobj.IsSceneObject ==true))
                    {
                        NetworkObject.SceneObject scobj = netobj.GetMessageSceneObject(targetClientId);
                        scobj.Serialize(writer);
                        count++;
                    }
                }
            }
            var tailPosition = writer.Position;
            writer.Seek(headPosition);
            writer.WriteValueSafe(count);
            writer.Seek(tailPosition);

            return;
        }

        internal void DeserializeScenePlacedObjects(FastBufferReader reader)
        {
            reader.ReadValueSafe(out sceneObjectCount);
            sceneObjects = new List<NetworkObject.SceneObject>();

            for (int i=0;i< sceneObjectCount;i++)
            {
                NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                obj.Deserialize(reader);
                sceneObjects.Add(obj);               
            }
        }

        public void Dispose()
        {
        }
    }

    public class NetworkSceneManager : INetworkSceneManager, IDisposable
    {
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的CreateLocalNetworkObject函数里被使用，决定了Spawn的游戏对象是否在DDOL。
        /// </summary>
        internal  static bool  IsSpawnedObjectsPendingInDontDestroyOnLoad;
        /// <summary>
        /// 这个参数在NetworkObject里的SceneChangedUpdate里被调用，用于将客户端场景句柄转换为服务端场景句柄
        /// </summary>
        internal Dictionary<int, int> ClientSceneHandleToServerSceneHandle = new Dictionary<int, int>();
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的ServerDestroySpawnedSceneObjects里被调用
        /// </summary>
        internal Scene DontDestroyOnLoadScene;

        private NetworkManager m_networkManager;

        private SceneEventData m_SceneEventData;

        internal SceneEventType m_curSceneEvent;//当前场景事件，如果为idle则合适处理一些事情

        internal Dictionary<ulong, string> m_ClientScene = new Dictionary<ulong, string>();//每个客户端的当前场景
        /// <summary>
        /// 缺省的场景
        /// </summary>
        private string m_DefaultScene;

        private Queue<string> m_scenesForLoad;
        private string m_curLoadScene;

        internal NetworkSceneManager(NetworkManager networkManager)
        {
            m_networkManager = networkManager;
            m_curSceneEvent = SceneEventType.Idle;
            m_networkManager.OnClientDisconnectCallback += OnDisconnect;
            m_networkManager.OnClientConnectedCallback += OnConnect;
        }

        internal void OnDisconnect(ulong id)
        {
            m_ClientScene.Remove(id);
            Debug.LogFormat("Disconnect {0}", id);
        }

        internal void OnConnect(ulong id)
        {
            m_ClientScene.Add(id, m_DefaultScene);
            Debug.LogFormat("Connect {0}", id);
        }
        /// <summary>
        /// 这个函数在NetworkObject里的SceneChangedUpdate函数里被调用
        /// </summary>
        /// <param name="networkObject"></param>
        internal void NotifyNetworkObjectSceneChanged(NetworkObject networkObject)
        {

        }

        /// <summary>
        /// 这个函数在NetworkSpawnManager里的HasPrefab里被调用
        /// 这个函数在NetworkSpawnManager里的CreateLocalNetworkObject里被调用
        /// </summary>
        /// <param name="globalObjectIdHash"></param>
        /// <param name="networkSceneHandle"></param>
        /// <returns></returns>
        internal NetworkObject GetSceneRelativeInSceneNetworkObject(uint globalObjectIdHash, int? networkSceneHandle)
        {
            foreach (NetworkObject no in GameObject.FindObjectsOfType<NetworkObject>())
            {
                if (no.GlobalObjectIdHash == globalObjectIdHash)
                {
                    return no;
                }
            }
            return null;
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <param name="senderId"></param>
        /// <param name="messageSize"></param>
        /// <param name="sceneObject"></param>
        /// <param name="fastBufferReader"></param>
        internal void DeferCreateObject(ulong senderId, uint messageSize, NetworkObject.SceneObject sceneObject, FastBufferReader fastBufferReader)
        {

        }

        /// <summary>
        /// 这个函数在NetworkCoonnectionManager的HandleConnectionApproval函数里被调用
        /// </summary>
        /// <param name="clientId"></param>
        internal void SynchronizeNetworkObjects(ulong clientId)
        {
            if (!m_networkManager.ConnectedClients[clientId].IsConnected)
            {
                m_networkManager.ConnectedClients[clientId].IsConnected = true;
                m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(clientId);
            }

            SceneEventData seData = new SceneEventData();
            seData.seType = SceneEventType.ClientSceneLoad;
            seData.targetClientId = clientId;
            seData.sceneName = m_ClientScene[clientId];
            var message = new SceneEventMessage
            {
                EventData = seData
            };
            m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
        }

        /// <summary>
        /// 这个函数在NetworkManager的NetworkUpdateStage.PostLateUpdate状态下被调用
        /// </summary>
        internal void CheckForAndSendNetworkObjectSceneChanged()
        {
            if(NetworkManager.Singleton.IsServer)
            {
                //向客户端发送活动对象进出场景事件

            }
            else
            {
                if (m_curSceneEvent != SceneEventType.Idle) return;//如果当前忙则不做处理
                //处理接收到的活动对象进出场景事件

            }
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <returns></returns>
        internal bool ShouldDeferCreateObject()
        {
            return false;
        }

        /// <summary>
        /// 客户端网络消息处理函数
        /// </summary>
        /// <param name="seData"></param>
        internal void HandleSceneEvent(SceneEventData seData)
        {
            if (m_networkManager.IsServer) return;

            if(seData.seType== SceneEventType.ClientSceneLoad)
            {
                if (!m_networkManager.IsConnectedClient)
                {
                    m_networkManager.IsConnectedClient = true;
                    m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(m_networkManager.LocalClientId);
                }
                IsSpawnedObjectsPendingInDontDestroyOnLoad = true;
                m_SceneEventData = seData;
                AsyncOperation op =SceneManager.LoadSceneAsync(seData.sceneName, LoadSceneMode.Single);
                op.completed += OnClientSceneLoadComplete;
            }
        }

        private void OnClientSceneLoadComplete(AsyncOperation op)
        {
            for(int i = 0; i< m_SceneEventData.sceneObjectCount; i++)
            {
                var networkObject = NetworkManager.Singleton.SpawnManager.CreateLocalNetworkObject(m_SceneEventData.sceneObjects[i]);
                if (networkObject != null)
                {
                    m_networkManager.SpawnManager.SpawnNetworkObjectLocally(networkObject, m_SceneEventData.sceneObjects[i], true);
                    networkObject.InternalInSceneNetworkObjectsSpawned();
                }
            }
            Scene sc = SceneManager.GetSceneByName(m_curLoadScene);
            MoveObjectsFromDontDestroyOnLoadToScene(sc);
            IsSpawnedObjectsPendingInDontDestroyOnLoad = false;
            if(m_curSceneEvent== SceneEventType.ClientSceneLoad)
                m_curSceneEvent = SceneEventType.Idle;
        }

        internal void MoveObjectsFromDontDestroyOnLoadToScene(Scene scene)
        {
            foreach (var networkObject in m_networkManager.SpawnManager.SpawnedObjectsList)
            {
                if (networkObject == null)
                {
                    continue;
                }
                // If it is in the DDOL then
                if (networkObject.gameObject.scene == DontDestroyOnLoadScene && !networkObject.DestroyWithScene)
                {
                    // only move dynamically spawned network objects, with no parent as child objects will follow,
                    // back into the currently active scene
                    if (networkObject.gameObject.transform.parent == null && networkObject.IsSceneObject != null && !networkObject.IsSceneObject.Value)
                    {
                        SceneManager.MoveGameObjectToScene(networkObject.gameObject, scene);
                    }
                }
            }
        }

        public void Dispose()
        {
            m_networkManager.OnClientDisconnectCallback -= OnDisconnect;
            m_networkManager.OnClientConnectedCallback -= OnConnect;
        }

        public AsyncOperation SvrLoadScene(string sceneName)
        {
            AsyncOperation op = SceneManager.LoadSceneAsync(sceneName,LoadSceneMode.Additive);
            return op;
        }

        public AsyncOperation SvrUnLoadScene(string sceneName)
        {
            return null;
        }

        public void SvrCreateAndMerageScene(string desScene, string srcScene, Vector3 offset)
        {

        }

        public void ClientSwitchScene(string curScene)
        {

        }

        public void SetDefaultScene(string defaultScene)
        {
            m_DefaultScene = defaultScene;
        }

        public void SvrLoadScenes(Queue<string> scenes)
        {
            if (scenes.Count==0) return;
            m_scenesForLoad = scenes;
            m_curLoadScene = m_scenesForLoad.Dequeue();
            AsyncOperation op = SvrLoadScene(m_curLoadScene);
            op.completed += OnSvrSceneLoadComplete;
        }

        private void OnSvrSceneLoadComplete(AsyncOperation op)
        {
            Debug.LogFormat("load scene {0} Completed", m_curLoadScene);
            int c=SvrSpawnSceneObjects(m_curLoadScene);
            Debug.LogFormat("spawn scene {0} Completed, {1} SceneObject Spawned", m_curLoadScene,c);
            if (m_scenesForLoad.Count == 0) return;
            m_curLoadScene = m_scenesForLoad.Dequeue();
            AsyncOperation op1 = SvrLoadScene(m_curLoadScene);
            op1.completed += OnSvrSceneLoadComplete;
        }

        private int SvrSpawnSceneObjects(string sceneName)
        {
            int count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return count;
            
            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach(var go in gameObjects)
            {
                NetworkObject[] objs=go.GetComponentsInChildren<NetworkObject>(true);
                foreach( var netobj in objs)
                {
                    if (!netobj.IsPlayerObject && (netobj.IsSceneObject == null||netobj.IsSceneObject==true))
                    {
                        m_networkManager.SpawnManager.SpawnNetworkObjectLocally(netobj, m_networkManager.SpawnManager.GetNetworkObjectId(), true, false, NetworkManager.ServerClientId, true);
                        netobj.InternalInSceneNetworkObjectsSpawned();
                        count++;
                    }
                }
            }

            return count;
        }
    }
}
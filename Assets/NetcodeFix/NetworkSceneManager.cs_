using System;
using Unity.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
///基于 Netcode for GameObjects 1.12.2 January 25, 2025 做出的修改
namespace Unity.Netcode
{
    enum SceneEventType
    {
        Idle,
        SvrSceneLoad,//服务端场景加载事件
        SvrSceneUnload,//服务端场景卸载事件
        ClientSceneLoad,//客户端场景加载事件
        ClientSceneMerge,//客户端场景合并事件
        ObjectSceneChanged,//客户端有新的网络对象更改场景事件
        Synchronize,//客户端同步动态网络对象事件
        SwitchScene//切换场景事件，客户端发送到服务端
    }

    internal class SceneEventData : IDisposable
    {
        internal SceneEventType seType;//事件类型
        internal ulong targetClientId;//目标客户端id
        internal string sceneName;//场景名称
        internal string srcScene;//源场景
        internal Vector3 offset;//场景偏移量
        internal ushort sceneObjectCount;//场景对象计数
        internal List<NetworkObject.SceneObject> sceneObjects;//场景对象列表
        internal ushort enterObjectCount;//进入场景的对象数
        internal ushort leaveObjectCount;//离开场景的对象数
        internal Queue<NetworkObject> enterQue;
        internal Queue<string> leaveQue;
        internal ushort networkObjectsCount;//需要同步的网络对象数目
        internal List<NetworkObject> networkObjectsSync;
        internal ushort despawnedInSceneObjectsCount;
        internal List<uint> despawnedInSceneObjectsSync;
        internal FastBufferReader InternalBuffer;//内部缓冲区
        internal bool hasBuffer;
        internal SceneEventData()
        {
            hasBuffer = false;
        }
        internal void Serialize(FastBufferWriter writer)
        {
            writer.WriteValueSafe(seType);
            writer.WriteValueSafe(targetClientId);
            if(seType== SceneEventType.SwitchScene)
            {
                writer.WriteValueSafe(sceneName);
            }
            if (seType == SceneEventType.ClientSceneLoad)
            {
                writer.WriteValueSafe(sceneName);
                SerializeScenePlacedObjects(writer);
            }
            if (seType == SceneEventType.ClientSceneMerge)
            {
                writer.WriteValueSafe(sceneName);
                writer.WriteValueSafe(srcScene);
                writer.WriteValueSafe(offset);
                SerializeScenePlacedObjects(writer);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                writer.WriteValueSafe(enterObjectCount);
                foreach (var obj in enterQue)
                {
                    NetworkObject.SceneObject scobj = obj.GetMessageSceneObject(targetClientId);
                    scobj.Serialize(writer);
                }
                writer.WriteValueSafe(leaveObjectCount);
                foreach (var obj in leaveQue)
                {
                    writer.WriteValueSafe((string)obj);
                }
            }
            if(seType == SceneEventType.Synchronize)
            {
                SerializeSynchronizationData(writer);
            }
        }

        internal void Deserialize(FastBufferReader reader)
        {
            reader.ReadValueSafe(out seType);
            reader.ReadValueSafe(out targetClientId);
            if (seType == SceneEventType.SwitchScene)
            {
                reader.ReadValueSafe(out sceneName);
            }

            if (seType == SceneEventType.ClientSceneLoad)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ClientSceneLoad;
                reader.ReadValueSafe(out sceneName);
                DeserializeScenePlacedObjects(reader);
            }

            if (seType == SceneEventType.ClientSceneMerge)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ClientSceneMerge;
                reader.ReadValueSafe(out sceneName);
                reader.ReadValueSafe(out srcScene);
                reader.ReadValueSafe(out offset);
                DeserializeScenePlacedObjects(reader);
            }

            if (seType == SceneEventType.ObjectSceneChanged)
            {
                //NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ObjectSceneChanged;

                unsafe
                {
                    InternalBuffer = new FastBufferReader(reader.GetUnsafePtrAtCurrentPosition(), Allocator.Persistent, reader.Length - reader.Position);
                    hasBuffer = true;
                }
            }
            if (seType == SceneEventType.Synchronize)
            {
                //NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.Synchronize;
                int byteCopy;
                reader.ReadValueSafe(out byteCopy);
                unsafe
                {
                    if (!reader.TryBeginRead(byteCopy))
                    {
                        throw new OverflowException("Not enough space in the buffer to read recorded synchronization data size.");
                    }

                    // We use Allocator.Persistent since scene synchronization will most likely take longer than 4 frames
                    InternalBuffer = new FastBufferReader(reader.GetUnsafePtrAtCurrentPosition(), Allocator.Persistent, byteCopy);
                    hasBuffer = true;
                }
            }
        }

        internal void SerializeScenePlacedObjects(FastBufferWriter writer)
        {
            var numberOfObjects = (ushort)0;
            var headPosition = writer.Position;
            writer.WriteValueSafe((ushort)0);

            ushort count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return;

            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (var go in gameObjects)
            {
                NetworkObject[] objs = go.GetComponentsInChildren<NetworkObject>(true);
                foreach (var netobj in objs)
                {
                    //只同步已经Spawn的场景内网络对象
                    if (!netobj.IsPlayerObject&&(netobj.IsSceneObject==null|| netobj.IsSceneObject ==true)&&netobj.IsSpawned)
                    {
                        NetworkObject.SceneObject scobj = netobj.GetMessageSceneObject(targetClientId);
                        scobj.Serialize(writer);
                        count++;
                    }
                }
            }
            var tailPosition = writer.Position;
            writer.Seek(headPosition);
            writer.WriteValueSafe(count);
            writer.Seek(tailPosition);

            return;
        }

        internal void DeserializeScenePlacedObjects(FastBufferReader reader)
        {
            unsafe
            {
                InternalBuffer = new FastBufferReader(reader.GetUnsafePtrAtCurrentPosition(), Allocator.Persistent, reader.Length - reader.Position);
                hasBuffer = true;
            }
        }

        internal void SerializeSynchronizationData(FastBufferWriter writer)
        {
            var positionStart = writer.Position;

            // Size Place Holder -- Start
            // !!NOTE!!: Since this is a placeholder to be set after we know how much we have written,
            // for stream offset purposes this MUST not be a packed value!
            writer.WriteValueSafe((int)0);

            // Write the number of NetworkObjects we are serializing
            writer.WriteValueSafe((ushort)networkObjectsSync.Count);

            // Serialize all NetworkObjects that are spawned
            for (var i = 0; i < networkObjectsSync.Count; ++i)
            {
                var noStart = writer.Position;
                var sceneObject = networkObjectsSync[i].GetMessageSceneObject(targetClientId);
                sceneObject.Serialize(writer);
                var noStop = writer.Position;
            }

            // Write the number of despawned in-scene placed NetworkObjects
            writer.WriteValueSafe((ushort)despawnedInSceneObjectsSync.Count);
            // Write the scene handle and GlobalObjectIdHash value
            for (var i = 0; i < despawnedInSceneObjectsSync.Count; ++i)
            {
                writer.WriteValueSafe(despawnedInSceneObjectsSync[i]);
            }

            // Size Place Holder -- End
            var positionEnd = writer.Position;
            var bytesWritten = (uint)(positionEnd - (positionStart + sizeof(uint)));
            writer.Seek(positionStart);
            // Write the total size written to the stream by NetworkObjects being serialized
            writer.WriteValueSafe((int)bytesWritten);
            writer.Seek(positionEnd);
        }

        public void Dispose()
        {
        }
    }

    public class NetworkSceneManager : INetworkSceneManager, IDisposable
    {
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的CreateLocalNetworkObject函数里被使用，决定了Spawn的游戏对象是否在DDOL。
        /// </summary>
        internal  static bool  IsSpawnedObjectsPendingInDontDestroyOnLoad;
        /// <summary>
        /// 这个参数在NetworkObject里的SceneChangedUpdate里被调用，用于将客户端场景句柄转换为服务端场景句柄
        /// </summary>
        internal Dictionary<int, int> ClientSceneHandleToServerSceneHandle = new Dictionary<int, int>();
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的ServerDestroySpawnedSceneObjects里被调用
        /// </summary>
        internal Scene DontDestroyOnLoadScene;

        private NetworkManager m_networkManager;

        private SceneEventData m_SceneEventDataClientSceneLoad = new SceneEventData();//用于存放场景加载事件数据

        private SceneEventData m_SceneEventDataSynchronize = new SceneEventData();//用于存放场景同步事件数据

        private SceneEventData m_SceneEventDataObjectSceneChanged = new SceneEventData();//用于存放网络对象跨场景事件数据

        internal SceneEventType m_curSceneEvent;//当前场景事件，如果为idle则合适处理一些事情(注意：服务端和客户端具备不同的事件)

        internal Dictionary<ulong, string> m_ClientScenes = new Dictionary<ulong, string>();//每个客户端的当前场景
        
        internal struct SceneChangeItem
        {
            internal int sceneHandle;
            internal string sceneName;
            internal Queue<NetworkObject> enterQue;
            internal Queue<NetworkObject> leaveQue;
        }
        
        internal Dictionary<int, SceneChangeItem> m_ObjectChangeScene = new Dictionary<int, SceneChangeItem>();//服务端使用的变量，每个场景的进出网络对象
        internal Dictionary<int, string> m_SceneHandleToName = new Dictionary<int, string>();//服务端使用的变量，场景句柄到场景名称的映射
        internal Dictionary<string,int> m_SceneNameToHandle = new Dictionary<string,int>();//服务端使用的变量，场景名称到场景句柄的映射
        List<NetworkObject> m_NetworkObjectsSync = new List<NetworkObject>();//服务端需要同步的网络对象
        List<uint> m_DespawnedInSceneObjectsSync = new List<uint>();
        

        SceneChangeItem m_SceneChangeItem;//客户端使用
        /// <summary>
        /// 缺省的场景
        /// </summary>
        private string m_DefaultScene;

        internal struct ServerSceneEvent
        {
            internal ulong id;//客户端id
            internal Scene des;
            internal string desScene;
            internal bool IsForLoad;
            internal string sceneName;
            internal Vector3 offset;
        }

        private Queue<ServerSceneEvent> m_sceneEvent=new Queue<ServerSceneEvent>();
        private Queue<ServerSceneEvent> m_sceneForMergeEvent = new Queue<ServerSceneEvent>();
        private Dictionary<string,string> m_MergeScenes = new Dictionary<string,string>();
        private string m_curLoadScene;
        private string m_curUnloadScene;
        private Scene m_DesScene;
        private string m_oldLoadScene;

        public delegate void OnServerSceneLoadCompleteHandler(string scname);

        public event OnServerSceneLoadCompleteHandler OnServerSceneLoadComplete;

        internal NetworkSceneManager(NetworkManager networkManager)
        {
            m_networkManager = networkManager;
            m_curSceneEvent = SceneEventType.Idle;
            m_SceneChangeItem.enterQue = new Queue<NetworkObject>();
            m_SceneChangeItem.leaveQue = new Queue<NetworkObject>();
            m_networkManager.OnClientDisconnectCallback += OnDisconnect;
            m_networkManager.OnClientConnectedCallback += OnConnect;
            DontDestroyOnLoadScene = m_networkManager.gameObject.scene;
        }

        internal void AddSpawnedNetworkObjects(ulong clientId)
        {
            m_NetworkObjectsSync.Clear();
            
            //这里需要修改为某一个场景内的SpawnedObjects
            
            foreach (var sobj in m_networkManager.SpawnManager.SpawnedObjectsList)
            {
                Debug.LogFormat("AddSpawnedNetworkObjects {0},{1}", sobj.gameObject.scene.name,sobj.gameObject.name);
                if ((sobj.IsSceneObject != null && sobj.IsSceneObject == false))//&&sobj.Observers.Contains(clientId)
                {
                    if (sobj.gameObject.scene.name == m_ClientScenes[clientId])
                    {
                        Debug.LogFormat("AddSpawnedNetworkObjects {0} success", sobj.gameObject.scene.name);
                        m_NetworkObjectsSync.Add(sobj);
                    }
                }
            }

            // Sort by INetworkPrefabInstanceHandler implementation before the
            // NetworkObjects spawned by the implementation
            m_NetworkObjectsSync.Sort(SortNetworkObjects);

            // The last thing we sort is parents before children
            SortParentedNetworkObjects();
        }

        internal void AddDespawnedInSceneNetworkObjects(ulong clientId)
        {
            //这里缺少对场景句柄的处理，应该是处理某客户端所处场景里的网络对象
            m_DespawnedInSceneObjectsSync.Clear();

            //ushort count = 0;
            Scene sc = SceneManager.GetSceneByName(m_ClientScenes[clientId]);
            if (sc == null || !sc.IsValid()) return;

            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (var go in gameObjects)
            {
                NetworkObject[] objs = go.GetComponentsInChildren<NetworkObject>(true);
                foreach (var netobj in objs)
                {
                    //只同步已经DeSpawn的场景内网络对象
                    if (!netobj.IsPlayerObject && netobj.IsSceneObject.HasValue &&  netobj.IsSceneObject.Value && !netobj.IsSpawned)
                    {
                        m_DespawnedInSceneObjectsSync.Add(netobj.GlobalObjectIdHash);
                        //NetworkObject.SceneObject scobj = netobj.GetMessageSceneObject(clientId);
                        //scobj.Serialize(writer);
                        //count++;
                    }
                }
            }

            //int localSceneHandle = m_SceneNameToHandle[m_ClientScenes[clientId]];
            //m_DespawnedInSceneObjectsSync.Clear();
            ////Find all active and non-active in-scene placed NetworkObjects
            //var inSceneNetworkObjects = UnityEngine.Object.FindObjectsOfType<NetworkObject>(includeInactive: true).Where((c) => c.NetworkManager == m_networkManager&& c.GetSceneOriginHandle() == localSceneHandle);

            //foreach (var sobj in inSceneNetworkObjects)
            //{
            //    if (sobj.IsSceneObject.HasValue && sobj.IsSceneObject.Value && !sobj.IsSpawned)
            //    {
            //        m_DespawnedInSceneObjectsSync.Add(sobj.GlobalObjectIdHash);
            //    }
            //}
        }

        //被AddSpawnedNetworkObjects调用
        private int SortNetworkObjects(NetworkObject first, NetworkObject second)
        {
            var doesFirstHaveHandler = m_networkManager.PrefabHandler.ContainsHandler(first);
            var doesSecondHaveHandler = m_networkManager.PrefabHandler.ContainsHandler(second);
            if (doesFirstHaveHandler != doesSecondHaveHandler)
            {
                if (doesFirstHaveHandler)
                {
                    return 1;
                }
                else
                {
                    return -1;
                }
            }
            return 0;
        }
        //被SortParentedNetworkObjects调用
        private int SortChildrenNetworkObjects(NetworkObject first, NetworkObject second)
        {
            var firstParent = first.GetCachedParent()?.GetComponent<NetworkObject>();
            // If the second is the first's parent then move the first down
            if (firstParent != null && firstParent == second)
            {
                return 1;
            }

            var secondParent = second.GetCachedParent()?.GetComponent<NetworkObject>();
            // If the first is the second's parent then move the first up
            if (secondParent != null && secondParent == first)
            {
                return -1;
            }

            // Otherwise, don't move the first at all
            return 0;
        }

        //被AddSpawnedNetworkObjects调用
        private void SortParentedNetworkObjects()
        {
            var networkObjectList = m_NetworkObjectsSync.ToList();
            foreach (var networkObject in networkObjectList)
            {
                // Find only the root parent NetworkObjects
                if (networkObject.transform.childCount > 0 && networkObject.transform.parent == null)
                {
                    // Get all child NetworkObjects of the root
                    var childNetworkObjects = networkObject.GetComponentsInChildren<NetworkObject>().ToList();

                    childNetworkObjects.Sort(SortChildrenNetworkObjects);

                    // Remove the root from the children list
                    childNetworkObjects.Remove(networkObject);

                    // Remove the root's children from the primary list
                    foreach (var childObject in childNetworkObjects)
                    {
                        m_NetworkObjectsSync.Remove(childObject);
                    }
                    // Insert or Add the sorted children list
                    var nextIndex = m_NetworkObjectsSync.IndexOf(networkObject) + 1;
                    if (nextIndex == m_NetworkObjectsSync.Count)
                    {
                        m_NetworkObjectsSync.AddRange(childNetworkObjects);
                    }
                    else
                    {
                        m_NetworkObjectsSync.InsertRange(nextIndex, childNetworkObjects);
                    }
                }
            }
        }

        internal void OnDisconnect(ulong id)
        {
            m_ClientScenes.Remove(id);
            Debug.LogFormat("Disconnect {0}", id);
        }

        internal void OnConnect(ulong id)
        {
            m_ClientScenes.Add(id, m_DefaultScene);
            Debug.LogFormat("Connect {0}", id);
        }
        /// <summary>
        /// 这个函数在NetworkObject里的SceneChangedUpdate函数里被调用
        /// </summary>
        /// <param name="networkObject"></param>
        internal void NotifyNetworkObjectSceneChanged(NetworkObject networkObject)
        {
            if (!m_networkManager.IsServer) return;
            int scOldHandle = networkObject.SceneOriginHandle;
            int scCurHandle = networkObject.NetworkSceneHandle;
            NetworkObject scobj = networkObject;

            if (!m_ObjectChangeScene.ContainsKey(scOldHandle))
            {
                SceneChangeItem item = new SceneChangeItem();
                item.sceneHandle = scOldHandle;
                item.sceneName = m_SceneHandleToName[scOldHandle];
                item.leaveQue = new Queue<NetworkObject>();
                item.enterQue = new Queue<NetworkObject>();
                item.leaveQue.Enqueue(scobj);
                m_ObjectChangeScene.Add(scOldHandle, item);
            }
            else
            {
                m_ObjectChangeScene[scOldHandle].leaveQue.Enqueue(scobj);
            }

            if (!m_ObjectChangeScene.ContainsKey(scCurHandle))
            {
                SceneChangeItem item = new SceneChangeItem();
                item.sceneHandle = scCurHandle;
                item.sceneName = m_SceneHandleToName[scCurHandle];
                item.leaveQue = new Queue<NetworkObject>();
                item.enterQue = new Queue<NetworkObject>();
                item.enterQue.Enqueue(scobj);
                m_ObjectChangeScene.Add(scCurHandle, item);
            }
            else
            {
                m_ObjectChangeScene[scCurHandle].enterQue.Enqueue(scobj);
            }

        }

        /// <summary>
        /// 这个函数在NetworkManager的NetworkUpdateStage.PostLateUpdate状态下被调用
        /// </summary>
        internal void CheckForAndSendNetworkObjectSceneChanged()
        {
            if (m_networkManager.IsServer)
            { 
                if (m_ObjectChangeScene.Count == 0) return;
                //向客户端发送活动对象进出场景事件
                foreach (var clientId in m_networkManager.ConnectedClientsIds)
                {
                    int scHandle=m_SceneNameToHandle[m_ClientScenes[clientId]];
                    if (m_ObjectChangeScene.ContainsKey(scHandle))
                    {
                        if(m_ObjectChangeScene[scHandle].enterQue.Count>0|| m_ObjectChangeScene[scHandle].leaveQue.Count>0)
                        {
                            SceneEventData seData = new SceneEventData();
                            seData.seType = SceneEventType.ObjectSceneChanged;
                            seData.targetClientId = clientId;
                            seData.sceneName = m_ClientScenes[clientId];
                            seData.enterObjectCount = (ushort)m_ObjectChangeScene[scHandle].enterQue.Count;
                            seData.leaveObjectCount = (ushort)m_ObjectChangeScene[scHandle].leaveQue.Count;
                            seData.enterQue= m_ObjectChangeScene[scHandle].enterQue;
                            seData.leaveQue = new Queue<string>();
                            foreach (var obj in m_ObjectChangeScene[scHandle].leaveQue)
                            {
                                seData.leaveQue.Enqueue(obj.gameObject.name);
                            }
                            var message = new SceneEventMessage
                            {
                                EventData = seData
                            };
                            m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
                        }
                    }
                }
                m_ObjectChangeScene.Clear();
            }
            else
            {
                if (m_curSceneEvent != SceneEventType.Idle) return;//如果当前忙则不做处理
                //处理接收到的同步网络对象。
                if (m_SceneEventDataSynchronize.hasBuffer)
                {
                    ushort sceneObjectCount;
                    m_SceneEventDataSynchronize.InternalBuffer.ReadValueSafe(out sceneObjectCount);
                    List<NetworkObject> sceneObjects = new List<NetworkObject>();

                    for (int i = 0; i < sceneObjectCount; i++)
                    {
                        NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                        obj.Deserialize(m_SceneEventDataSynchronize.InternalBuffer);
                        var networkObject = NetworkObject.AddSceneObject(obj, m_SceneEventDataSynchronize.InternalBuffer, m_networkManager);
                        if(networkObject!=null)
                            sceneObjects.Add(networkObject);
                    }

                    foreach (var networkObject in sceneObjects)
                    {
                        networkObject.InternalInSceneNetworkObjectsSpawned();
                    }
                    sceneObjects.Clear();

                    ushort despawnedInSceneObjectsSyncCount;
                    m_SceneEventDataSynchronize.InternalBuffer.ReadValueSafe(out despawnedInSceneObjectsSyncCount);

                    for (var i = 0; i < despawnedInSceneObjectsSyncCount; ++i)
                    {
                        uint GlobalObjectIdHash;
                        m_SceneEventDataSynchronize.InternalBuffer.ReadValueSafe(out GlobalObjectIdHash);
                        //do something with GlobalObjectIdHash。
                        var inSceneNetworkObjects = UnityEngine.Object.FindObjectsOfType<NetworkObject>(includeInactive: true).Where((c) =>
                            (c.IsSceneObject != false)).ToList();
                        foreach (var inSceneObject in inSceneNetworkObjects)
                        {
                            if (inSceneObject.GlobalObjectIdHash == GlobalObjectIdHash)
                                inSceneObject.InvokeBehaviourNetworkDespawn();
                        }
                    }

                    m_SceneEventDataSynchronize.hasBuffer = false;
                }

                //处理接收到的活动对象进出场景事件
                if (m_SceneEventDataObjectSceneChanged.hasBuffer)
                {
                    ushort enterObjectCount;
                    m_SceneEventDataObjectSceneChanged.InternalBuffer.ReadValueSafe(out enterObjectCount);
                    List<NetworkObject>  enterQue = new List<NetworkObject>();
                    for (int i = 0; i < enterObjectCount; i++)
                    {
                        NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                        obj.Deserialize(m_SceneEventDataObjectSceneChanged.InternalBuffer);
                        var networkObject = NetworkObject.AddSceneObject(obj, m_SceneEventDataObjectSceneChanged.InternalBuffer, m_networkManager);
                        if(networkObject!=null)
                            enterQue.Add(networkObject);
                    }
                    foreach (var networkObject in enterQue)
                    {
                        networkObject.InternalInSceneNetworkObjectsSpawned();
                    }
                    enterQue.Clear();

                    ushort leaveObjectCount;
                    m_SceneEventDataObjectSceneChanged.InternalBuffer.ReadValueSafe(out leaveObjectCount);
                    for (int i = 0; i < leaveObjectCount; i++)
                    {
                        string objName;
                        m_SceneEventDataObjectSceneChanged.InternalBuffer.ReadValueSafe(out objName);
                        GameObject obj=GameObject.Find(objName);
                        if (obj != null)
                            GameObject.Destroy(obj);
                    }

                    m_SceneEventDataObjectSceneChanged.hasBuffer = false;
                }
            }
        }

        /// <summary>
        /// 这个函数在NetworkSpawnManager里的HasPrefab里被调用
        /// 这个函数在NetworkSpawnManager里的CreateLocalNetworkObject里被调用
        /// </summary>
        /// <param name="globalObjectIdHash"></param>
        /// <param name="networkSceneHandle"></param>
        /// <returns></returns>
        internal NetworkObject GetSceneRelativeInSceneNetworkObject(uint globalObjectIdHash, int? networkSceneHandle)
        {
            //因为只在客户端调用，客户端只存在一个场景，所以忽略networkSceneHandle参数
            //这个地方可以进一步性能优化
            foreach (NetworkObject no in GameObject.FindObjectsOfType<NetworkObject>())
            {
                if (no.GlobalObjectIdHash == globalObjectIdHash)
                {
                    return no;
                }
            }
            return null;
        }

        internal struct DeferredObjectCreation
        {
            internal ulong SenderId;
            internal uint MessageSize;
            internal NetworkObject.SceneObject SceneObject;
            internal FastBufferReader FastBufferReader;
        }

        internal List<DeferredObjectCreation> DeferredObjectCreationList = new List<DeferredObjectCreation>();
        internal int DeferredObjectCreationCount;

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <param name="senderId"></param>
        /// <param name="messageSize"></param>
        /// <param name="sceneObject"></param>
        /// <param name="fastBufferReader"></param>
        internal void DeferCreateObject(ulong senderId, uint messageSize, NetworkObject.SceneObject sceneObject, FastBufferReader fastBufferReader)
        {
            var deferredObjectCreationEntry = new DeferredObjectCreation()
            {
                SenderId = senderId,
                MessageSize = messageSize,
                SceneObject = sceneObject,
            };

            unsafe
            {
                deferredObjectCreationEntry.FastBufferReader = new FastBufferReader(fastBufferReader.GetUnsafePtrAtCurrentPosition(), Allocator.Persistent, fastBufferReader.Length - fastBufferReader.Position);
            }

            DeferredObjectCreationList.Add(deferredObjectCreationEntry);
        }

        private void ProcessDeferredCreateObjectMessages()
        {
            // If no pending create object messages exit early
            if (DeferredObjectCreationList.Count == 0)
            {
                return;
            }
            var networkManager = m_networkManager;
            // Process all deferred create object messages.
            foreach (var deferredObjectCreation in DeferredObjectCreationList)
            {
                CreateObjectMessage.CreateObject(ref networkManager, deferredObjectCreation.SenderId, deferredObjectCreation.MessageSize, deferredObjectCreation.SceneObject, deferredObjectCreation.FastBufferReader);
            }
            DeferredObjectCreationCount = DeferredObjectCreationList.Count;
            DeferredObjectCreationList.Clear();
        }

        /// <summary>
        /// 这个函数在NetworkCoonnectionManager的HandleConnectionApproval函数里被调用
        /// </summary>
        /// <param name="clientId"></param>
        internal void SynchronizeNetworkObjects(ulong clientId)
        {
            //更新和触发OnConnect事件
            if (!m_networkManager.ConnectedClients[clientId].IsConnected)
            {
                m_networkManager.ConnectedClients[clientId].IsConnected = true;
                m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(clientId);
            }

            if (m_MergeScenes.ContainsKey(m_ClientScenes[clientId]))
            {
                //发送MergeScene消息
                Debug.Log("发送MergeScene消息");
                SceneEventData seData = new SceneEventData();
                seData.seType = SceneEventType.ClientSceneMerge;
                seData.targetClientId = clientId;
                seData.sceneName = m_ClientScenes[clientId];
                seData.srcScene = m_MergeScenes[m_ClientScenes[clientId]];
                var message = new SceneEventMessage
                {
                    EventData = seData
                };
                m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
            }
            else
            {   //同步场景和场景内的静态网络对象
                SceneEventData seData = new SceneEventData();
                seData.seType = SceneEventType.ClientSceneLoad;
                seData.targetClientId = clientId;
                seData.sceneName = m_ClientScenes[clientId];
                var message = new SceneEventMessage
                {
                    EventData = seData
                };
                m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
            }
           
            //同步动态生成的网络对象
            //更新客户端可见性
            m_networkManager.SpawnManager.UpdateObservedNetworkObjects(clientId);
            //生成需要同步的网络对象列表
            AddSpawnedNetworkObjects(clientId);
            AddDespawnedInSceneNetworkObjects(clientId);
            //发送消息同步网络对象
            SceneEventData seData1 = new SceneEventData();
            seData1.seType = SceneEventType.Synchronize;
            seData1.targetClientId = clientId;
            seData1.sceneName = m_ClientScenes[clientId];
            seData1.networkObjectsSync = new List<NetworkObject>();
            foreach (var obj in m_NetworkObjectsSync)
                seData1.networkObjectsSync.Add(obj);
            seData1.despawnedInSceneObjectsSync = new List<uint>();
            foreach (var obj in m_DespawnedInSceneObjectsSync)
                seData1.despawnedInSceneObjectsSync.Add(obj);
            var message1 = new SceneEventMessage
            {
                EventData = seData1
            };
            m_networkManager.ConnectionManager.SendMessage(ref message1, NetworkDelivery.ReliableFragmentedSequenced, clientId);
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <returns></returns>
        internal bool ShouldDeferCreateObject()
        {
            if (!m_networkManager.NetworkConfig.EnableSceneManagement || m_networkManager.IsServer)
            {
                return false;
            }

            return !IsIdle();
        }

        /// <summary>
        /// 客户端网络消息处理函数
        /// </summary>
        /// <param name="seData"></param>
        internal void HandleSceneEvent(SceneEventData seData)
        {
            if (m_networkManager.IsServer)
            {
                if(seData.seType == SceneEventType.SwitchScene)
                {
                    m_ClientScenes[seData.targetClientId] = seData.sceneName;
                    SynchronizeNetworkObjects(seData.targetClientId);
                }
            }
            else
            {
                if (seData.seType == SceneEventType.ClientSceneLoad)
                {
                    if (!m_networkManager.IsConnectedClient)
                    {
                        m_networkManager.IsConnectedClient = true;
                        m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(m_networkManager.LocalClientId);
                    }
                    IsSpawnedObjectsPendingInDontDestroyOnLoad = true;
                    m_SceneEventDataClientSceneLoad = seData;
                    m_oldLoadScene = m_curLoadScene;
                    m_curLoadScene = seData.sceneName;
                    AsyncOperation op = SceneManager.LoadSceneAsync(m_curLoadScene, LoadSceneMode.Single);
                    op.completed += OnClientSceneLoadComplete;
                }

                if (seData.seType == SceneEventType.ClientSceneMerge)
                {
                    if (!m_networkManager.IsConnectedClient)
                    {
                        m_networkManager.IsConnectedClient = true;
                        m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(m_networkManager.LocalClientId);
                    }
                    IsSpawnedObjectsPendingInDontDestroyOnLoad = true;
                    m_SceneEventDataClientSceneLoad = seData;
                    m_oldLoadScene = m_curLoadScene;
                    m_curLoadScene = seData.sceneName;
                    m_DesScene= SceneManager.CreateScene(seData.sceneName);
                    Debug.LogFormat("ClientSceneMerge:{0},{1}", seData.sceneName,m_curLoadScene);
                    AsyncOperation op = SceneManager.LoadSceneAsync(seData.srcScene, LoadSceneMode.Additive);
                    op.completed += OnClientSceneMergeComplete;
                }

                if (seData.seType == SceneEventType.ObjectSceneChanged)
                {
                    m_SceneEventDataObjectSceneChanged = seData;
                }

                if(seData.seType == SceneEventType.Synchronize)
                {
                    m_SceneEventDataSynchronize = seData;
                }
            }
        }

        private void OnClientSceneMergeComplete(AsyncOperation op)
        {
            Scene sc = SceneManager.GetSceneByName(m_SceneEventDataClientSceneLoad.srcScene);
            SceneManager.MergeScenes(sc,m_DesScene);
            SceneManager.SetActiveScene(m_DesScene);
            Debug.Log("UnloadScene:"+ m_oldLoadScene);
            SceneManager.UnloadScene(m_oldLoadScene);

            OffsetScene(m_DesScene, m_SceneEventDataClientSceneLoad.offset);
            Debug.LogFormat("OffsetScene {0} {1}", m_SceneEventDataClientSceneLoad.sceneName, m_SceneEventDataClientSceneLoad.offset);

            ushort sceneObjectCount;
            m_SceneEventDataClientSceneLoad.InternalBuffer.ReadValueSafe(out sceneObjectCount);
            List<NetworkObject> sceneObjects = new List<NetworkObject>();

            for (int i = 0; i < sceneObjectCount; i++)
            {
                NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                obj.Deserialize(m_SceneEventDataClientSceneLoad.InternalBuffer);
                var networkObject = NetworkObject.AddSceneObject(obj, m_SceneEventDataClientSceneLoad.InternalBuffer, m_networkManager);
                sceneObjects.Add(networkObject);
            }

            foreach (var networkObject in sceneObjects)
            {
                networkObject.InternalInSceneNetworkObjectsSpawned();
            }

            MoveObjectsFromDontDestroyOnLoadToScene(m_DesScene);
            IsSpawnedObjectsPendingInDontDestroyOnLoad = false;

            ProcessDeferredCreateObjectMessages();

            if (m_curSceneEvent == SceneEventType.ClientSceneMerge)
                m_curSceneEvent = SceneEventType.Idle;
        }

        private void OnClientSceneLoadComplete(AsyncOperation op)
        {
            ushort sceneObjectCount;
            m_SceneEventDataClientSceneLoad.InternalBuffer.ReadValueSafe(out sceneObjectCount);
            List<NetworkObject>  sceneObjects = new List<NetworkObject>();

            for (int i = 0; i < sceneObjectCount; i++)
            {
                NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                obj.Deserialize(m_SceneEventDataClientSceneLoad.InternalBuffer);
                var networkObject = NetworkObject.AddSceneObject(obj, m_SceneEventDataClientSceneLoad.InternalBuffer, m_networkManager);
                sceneObjects.Add(networkObject);
            }

            foreach (var networkObject in sceneObjects)
            {
                networkObject.InternalInSceneNetworkObjectsSpawned();
            }

            Scene sc = SceneManager.GetSceneByName(m_curLoadScene);
            MoveObjectsFromDontDestroyOnLoadToScene(sc);
            IsSpawnedObjectsPendingInDontDestroyOnLoad = false;

            ProcessDeferredCreateObjectMessages();

            if (m_curSceneEvent== SceneEventType.ClientSceneLoad)
                m_curSceneEvent = SceneEventType.Idle;
        }

        internal void MoveObjectsFromDontDestroyOnLoadToScene(Scene scene)
        {
            foreach (var networkObject in m_networkManager.SpawnManager.SpawnedObjectsList)
            {
                if (networkObject == null)
                {
                    continue;
                }
                // If it is in the DDOL then
                if (networkObject.gameObject.scene == DontDestroyOnLoadScene && !networkObject.DestroyWithScene)
                {
                    // only move dynamically spawned network objects, with no parent as child objects will follow,
                    // back into the currently active scene
                    if (networkObject.gameObject.transform.parent == null && networkObject.IsSceneObject != null && !networkObject.IsSceneObject.Value)
                    {
                        SceneManager.MoveGameObjectToScene(networkObject.gameObject, scene);
                    }
                }
            }
        }

        public void Dispose()
        {
            m_networkManager.OnClientDisconnectCallback -= OnDisconnect;
            m_networkManager.OnClientConnectedCallback -= OnConnect;
        }

        public bool IsIdle()
        {
            return (m_curSceneEvent == SceneEventType.Idle && m_sceneEvent.Count == 0);
        }

        public void SvrLoadScene(string sceneName)
        {
            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.IsForLoad = true;
            ssEvent.sceneName = sceneName;
            m_sceneEvent.Enqueue(ssEvent);
            if (m_sceneEvent.Count > 1) return;
            ProcessServerSceneEvent();
        }

        public void SvrUnloadScene(string sceneName)
        {
            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.IsForLoad = false;
            ssEvent.sceneName = sceneName;
            m_sceneEvent.Enqueue(ssEvent);
            if (m_sceneEvent.Count > 1) return;
            ProcessServerSceneEvent();
        }

        public void SvrCreateAndMergeScene(ulong id,string desScene, string srcScene, Vector3 offset)
        {
            Scene newScene = SceneManager.CreateScene(desScene);

            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.id = id;
            ssEvent.des = newScene;
            ssEvent.IsForLoad = true;
            ssEvent.sceneName = srcScene;
            ssEvent.desScene = desScene;
            ssEvent.offset = offset;
            m_sceneForMergeEvent.Enqueue(ssEvent);
            if (m_sceneForMergeEvent.Count > 1) return;
            ProcessServerSceneForMergeEvent();
        }

        private void OffsetScene(Scene sc,Vector3 offset)
        {
            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (GameObject go in gameObjects)
            {
                go.transform.localPosition += offset;
            }
        }

        private void OnSvrSceneForMergeLoadComplete(AsyncOperation op)
        {
            ServerSceneEvent e =m_sceneForMergeEvent.Dequeue();
            Scene src=SceneManager.GetSceneByName(e.sceneName);
            SceneManager.MergeScenes(src,e.des);
            Debug.LogFormat("srcScene:{0},desScene:{1}", e.sceneName, e.desScene);
            
            OffsetScene(e.des,e.offset);
            Debug.LogFormat("offset scene {0} {1}",e.desScene,e.offset);

            m_MergeScenes.Add(e.desScene, e.sceneName);
            Debug.LogFormat("Merage scene {0},{1} Completed", e.desScene, e.sceneName);
            int c = SvrSpawnSceneObjects(e.desScene);
            Debug.LogFormat("spawn scene {0} Completed, {1} SceneObject Spawned", e.desScene, c);

            ServerSwitchScene(e.id, e.desScene);

            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneForMergeEvent();
        }

        public void ServerSwitchScene(ulong id, string curScene)
        {
            if (m_networkManager.IsClient) return;

            if (m_ClientScenes.ContainsKey(id))
            {
                m_ClientScenes[id] = curScene;
                SynchronizeNetworkObjects(id);
            }
        }

        public void ClientSwitchScene(string curScene)
        {
            if (m_networkManager.IsServer) return;

            SceneEventData seData = new SceneEventData();
            seData.seType = SceneEventType.SwitchScene;
            seData.targetClientId = m_networkManager.LocalClientId;
            seData.sceneName = curScene;
            var message = new SceneEventMessage
            {
                EventData = seData
            };
            m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, NetworkManager.ServerClientId);
        }

        public void SetDefaultScene(string defaultScene)
        {
            m_DefaultScene = defaultScene;
        }
        
        private void OnProcessServerSceneEventEnd()
        {
            m_SceneHandleToName.Clear();
            m_SceneNameToHandle.Clear();
            //生成句柄和场景名称的映射字典
            m_SceneHandleToName.Add(DontDestroyOnLoadScene.handle, DontDestroyOnLoadScene.name);
            m_SceneNameToHandle.Add(DontDestroyOnLoadScene.name,DontDestroyOnLoadScene.handle);
            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene sc = SceneManager.GetSceneAt(i);
                Debug.LogFormat("scname:{0} schandle:{1}", sc.name, sc.handle);
                m_SceneHandleToName.Add(sc.handle, sc.name);
                m_SceneNameToHandle.Add(sc.name,sc.handle);
            }
            OnServerSceneLoadComplete?.Invoke(m_curLoadScene);
        }

        private void ProcessServerSceneForMergeEvent()
        {
            if (m_sceneForMergeEvent.Count == 0)
            {
                m_curSceneEvent = SceneEventType.Idle;
                OnProcessServerSceneEventEnd();
                return;
            }

            if (m_curSceneEvent != SceneEventType.Idle)
                return;


            bool bFailed;
            do
            {
                ServerSceneEvent ssEvent = m_sceneForMergeEvent.Peek();
                bFailed = false;
                if (ssEvent.IsForLoad)
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneLoad;
                        m_curLoadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.LoadSceneAsync(ssEvent.sceneName, LoadSceneMode.Additive);
                        op.completed += OnSvrSceneForMergeLoadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("LoadScene {0} Exception caught: {1}", m_curLoadScene, e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
            } while (bFailed && m_sceneForMergeEvent.Count > 0);

            m_curSceneEvent = SceneEventType.Idle;
            OnProcessServerSceneEventEnd();
            return;
        }

        private void ProcessServerSceneEvent()
        {
            if (m_sceneEvent.Count == 0)
            {
                m_curSceneEvent = SceneEventType.Idle;
                OnProcessServerSceneEventEnd();
                return;
            }

            if (m_curSceneEvent != SceneEventType.Idle)
                return;

            
            bool bFailed;
            do
            {
                ServerSceneEvent ssEvent = m_sceneEvent.Peek();
                bFailed = false;
                if (ssEvent.IsForLoad)
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneLoad;
                        m_curLoadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.LoadSceneAsync(ssEvent.sceneName, LoadSceneMode.Additive);
                        op.completed += OnSvrSceneLoadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("LoadScene {0} Exception caught: {1}", m_curLoadScene,e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
                else
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneUnload;
                        m_curUnloadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.UnloadSceneAsync(ssEvent.sceneName, UnloadSceneOptions.None);
                        op.completed += OnSvrSceneUnloadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("UnloadScene {0} Exception caught: {1}", m_curLoadScene,e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
            } while (bFailed&& m_sceneEvent.Count>0);

           m_curSceneEvent = SceneEventType.Idle;
           OnProcessServerSceneEventEnd();
           return;
        }

        private void OnSvrSceneUnloadComplete(AsyncOperation op)
        {
            ServerSceneEvent ssEvent=m_sceneEvent.Dequeue();
            if(m_MergeScenes.ContainsKey(ssEvent.sceneName)) m_MergeScenes.Remove(ssEvent.sceneName);
            Debug.LogFormat("Unload scene {0} Completed", ssEvent.sceneName);
            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneEvent();
        }

        private void OnSvrSceneLoadComplete(AsyncOperation op)
        {
            ServerSceneEvent ssEvent = m_sceneEvent.Dequeue();

            Debug.LogFormat("load scene {0} Completed", ssEvent.sceneName);
            int c = SvrSpawnSceneObjects(ssEvent.sceneName);
            Debug.LogFormat("spawn scene {0} Completed, {1} SceneObject Spawned", ssEvent.sceneName, c);
            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneEvent();
        }

        private int SvrSpawnSceneObjects(string sceneName)
        {
            int count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return count;
            Debug.LogFormat("SvrSpawnSceneObjects:{0}", sceneName);
            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach(var go in gameObjects)
            {
                NetworkObject[] objs=go.GetComponentsInChildren<NetworkObject>(true);
                foreach( var netobj in objs)
                {
                    if (!netobj.IsPlayerObject && (netobj.IsSceneObject == null||netobj.IsSceneObject==true))
                    {
                        m_networkManager.SpawnManager.SpawnNetworkObjectLocally(netobj, m_networkManager.SpawnManager.GetNetworkObjectId(), true, false, NetworkManager.ServerClientId, true);
                        netobj.InternalInSceneNetworkObjectsSpawned();
                        count++;
                    }
                }
            }

            return count;
        }
    }
}
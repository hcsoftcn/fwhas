using System;
using Unity.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
///基于 Netcode for GameObjects 1.12.2 January 25, 2025 做出的修改
namespace Unity.Netcode
{
    enum SceneEventType
    {
        Idle,
        SvrSceneLoad,//服务端场景加载事件
        SvrSceneUnload,//服务端场景卸载事件
        ClientSceneLoad,//客户端场景加载事件
        ObjectSceneChanged,//客户端有新的网络对象更改场景事件
        Synchronize//客户端同步动态网络对象事件
    }

    internal class SceneEventData : IDisposable
    {
        internal SceneEventType seType;//事件类型
        internal ulong targetClientId;//目标客户端id
        internal string sceneName;//场景名称
        internal ushort sceneObjectCount;//场景对象计数
        internal List<NetworkObject.SceneObject> sceneObjects;//场景对象列表
        internal ushort enterObjectCount;//进入场景的对象数
        internal ushort leaveObjectCount;//离开场景的对象数
        internal Queue<NetworkObject.SceneObject> enterQue;
        internal Queue<NetworkObject.SceneObject> leaveQue;
        internal ushort networkObjectsCount;//需要同步的网络对象数目
        internal List<NetworkObject> networkObjectsSync;
        internal ushort despawnedInSceneObjectsCount;
        internal List<uint> despawnedInSceneObjectsSync;
        internal FastBufferReader InternalBuffer;//内部缓冲区

        internal void Serialize(FastBufferWriter writer)
        {
            writer.WriteValueSafe(seType);
            writer.WriteValueSafe(targetClientId);
            if (seType == SceneEventType.ClientSceneLoad)
            {
                writer.WriteValueSafe(sceneName);
                SerializeScenePlacedObjects(writer);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                writer.WriteValueSafe(enterObjectCount);
                foreach (var obj in enterQue)
                {
                    obj.Serialize(writer);
                }
                writer.WriteValueSafe(leaveObjectCount);
                foreach (var obj in leaveQue)
                {
                    obj.Serialize(writer);
                }
            }
            if(seType == SceneEventType.Synchronize)
            {
                SerializeSynchronizationData(writer);
            }
        }

        internal void Deserialize(FastBufferReader reader)
        {
            reader.ReadValueSafe(out seType);
            reader.ReadValueSafe(out targetClientId);
            if (seType == SceneEventType.ClientSceneLoad)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ClientSceneLoad;
                reader.ReadValueSafe(out sceneName);
                DeserializeScenePlacedObjects(reader);
            }
            if (seType == SceneEventType.ObjectSceneChanged)
            {
                NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.ObjectSceneChanged;
                reader.ReadValueSafe(out enterObjectCount);
                enterQue = new Queue<NetworkObject.SceneObject>();
                for (int i = 0; i < enterObjectCount; i++)
                {
                    NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                    obj.Deserialize(reader);
                    enterQue.Enqueue(obj);
                }
                reader.ReadValueSafe(out leaveObjectCount);
                leaveQue = new Queue<NetworkObject.SceneObject>();
                for (int i = 0; i < leaveObjectCount; i++)
                {
                    NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                    obj.Deserialize(reader);
                    leaveQue.Enqueue(obj);
                }
                if(NetworkManager.Singleton.SceneManager.m_curSceneEvent== SceneEventType.ObjectSceneChanged)
                    NetworkManager.Singleton.SceneManager.m_curSceneEvent = SceneEventType.Idle;
            }
            if (seType == SceneEventType.Synchronize)
            {
                int byteCopy;
                reader.ReadValueSafe(out byteCopy);
                unsafe
                {
                    if (!reader.TryBeginRead(byteCopy))
                    {
                        throw new OverflowException("Not enough space in the buffer to read recorded synchronization data size.");
                    }

                    // We use Allocator.Persistent since scene synchronization will most likely take longer than 4 frames
                    InternalBuffer = new FastBufferReader(reader.GetUnsafePtrAtCurrentPosition(), Allocator.Persistent, byteCopy);
                }
            }
        }

        internal void SerializeScenePlacedObjects(FastBufferWriter writer)
        {
            var numberOfObjects = (ushort)0;
            var headPosition = writer.Position;
            writer.WriteValueSafe((ushort)0);

            ushort count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return;

            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach (var go in gameObjects)
            {
                NetworkObject[] objs = go.GetComponentsInChildren<NetworkObject>(true);
                foreach (var netobj in objs)
                {
                    //只同步已经Spawn的场景内网络对象
                    if (!netobj.IsPlayerObject&&(netobj.IsSceneObject==null|| netobj.IsSceneObject ==true)&&netobj.IsSpawned)
                    {
                        NetworkObject.SceneObject scobj = netobj.GetMessageSceneObject(targetClientId);
                        scobj.Serialize(writer);
                        count++;
                    }
                }
            }
            var tailPosition = writer.Position;
            writer.Seek(headPosition);
            writer.WriteValueSafe(count);
            writer.Seek(tailPosition);

            return;
        }

        internal void DeserializeScenePlacedObjects(FastBufferReader reader)
        {
            unsafe
            {
                InternalBuffer = new FastBufferReader(reader.GetUnsafePtrAtCurrentPosition(), Allocator.Persistent, reader.Length - reader.Position);
            }
        }

        internal void SerializeSynchronizationData(FastBufferWriter writer)
        {
            var positionStart = writer.Position;

            // Size Place Holder -- Start
            // !!NOTE!!: Since this is a placeholder to be set after we know how much we have written,
            // for stream offset purposes this MUST not be a packed value!
            writer.WriteValueSafe((int)0);
            // uint totalBytes = 0;

            // Write the number of NetworkObjects we are serializing
            writer.WriteValueSafe((ushort)networkObjectsSync.Count);

            // Serialize all NetworkObjects that are spawned
            for (var i = 0; i < networkObjectsSync.Count; ++i)
            {
                var noStart = writer.Position;
                var sceneObject = networkObjectsSync[i].GetMessageSceneObject(targetClientId);
                sceneObject.Serialize(writer);
                var noStop = writer.Position;
                //totalBytes += noStop - noStart;
            }

            // Write the number of despawned in-scene placed NetworkObjects
            writer.WriteValueSafe((ushort)despawnedInSceneObjectsSync.Count);
            // Write the scene handle and GlobalObjectIdHash value
            for (var i = 0; i < despawnedInSceneObjectsSync.Count; ++i)
            {
                //var noStart = writer.Position;
                writer.WriteValueSafe(despawnedInSceneObjectsSync[i]);
                //var noStop = writer.Position;
                //totalBytes += noStop - noStart;
            }

            // Size Place Holder -- End
            var positionEnd = writer.Position;
            var bytesWritten = (uint)(positionEnd - (positionStart + sizeof(uint)));
            writer.Seek(positionStart);
            // Write the total size written to the stream by NetworkObjects being serialized
            writer.WriteValueSafe((int)bytesWritten);
            writer.Seek(positionEnd);
        }

        public void Dispose()
        {
        }
    }

    public class NetworkSceneManager : INetworkSceneManager, IDisposable
    {
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的CreateLocalNetworkObject函数里被使用，决定了Spawn的游戏对象是否在DDOL。
        /// </summary>
        internal  static bool  IsSpawnedObjectsPendingInDontDestroyOnLoad;
        /// <summary>
        /// 这个参数在NetworkObject里的SceneChangedUpdate里被调用，用于将客户端场景句柄转换为服务端场景句柄
        /// </summary>
        internal Dictionary<int, int> ClientSceneHandleToServerSceneHandle = new Dictionary<int, int>();
        /// <summary>
        /// 这个参数在NetworkSpawnManager里的ServerDestroySpawnedSceneObjects里被调用
        /// </summary>
        internal Scene DontDestroyOnLoadScene;

        private NetworkManager m_networkManager;

        private SceneEventData m_SceneEventData;//用于服务端向客户端发送场景同步指令

        private SceneEventData m_SceneEventDataClientSceneLoad;//用于存放场景同步事件数据

        internal SceneEventType m_curSceneEvent;//当前场景事件，如果为idle则合适处理一些事情(注意：服务端和客户端具备不同的事件)

        internal Dictionary<ulong, string> m_ClientScenes = new Dictionary<ulong, string>();//每个客户端的当前场景
        
        internal struct SceneChangeItem
        {
            internal int sceneHandle;
            internal string sceneName;
            internal Queue<NetworkObject.SceneObject> enterQue;
            internal Queue<NetworkObject.SceneObject> leaveQue;
        }
        
        internal Dictionary<int, SceneChangeItem> m_ObjectChangeScene = new Dictionary<int, SceneChangeItem>();//服务端使用的变量，每个场景的进出网络对象
        internal Dictionary<int, string> m_SceneHandleToName = new Dictionary<int, string>();//服务端使用的变量，场景句柄到场景名称的映射
        internal Dictionary<string,int> m_SceneNameToHandle = new Dictionary<string,int>();//服务端使用的变量，场景名称到场景句柄的映射
        List<NetworkObject> m_NetworkObjectsSync = new List<NetworkObject>();//服务端需要同步的网络对象
        List<uint> m_DespawnedInSceneObjectsSync = new List<uint>();
        List<NetworkObject.SceneObject> m_NetworkObjectsClientSync = new List<NetworkObject.SceneObject>();//客户端接受到的需要同步的网络对象
        SceneChangeItem m_SceneChangeItem;//客户端使用
        /// <summary>
        /// 缺省的场景
        /// </summary>
        private string m_DefaultScene;

        internal struct ServerSceneEvent
        {
            internal bool IsForLoad;
            internal string sceneName;
        }

        private Queue<ServerSceneEvent> m_sceneEvent=new Queue<ServerSceneEvent>();
        private string m_curLoadScene;
        private string m_curUnloadScene;

        internal NetworkSceneManager(NetworkManager networkManager)
        {
            m_networkManager = networkManager;
            m_curSceneEvent = SceneEventType.Idle;
            m_SceneChangeItem.enterQue = new Queue<NetworkObject.SceneObject>();
            m_SceneChangeItem.leaveQue = new Queue<NetworkObject.SceneObject>();
            m_networkManager.OnClientDisconnectCallback += OnDisconnect;
            m_networkManager.OnClientConnectedCallback += OnConnect;
            DontDestroyOnLoadScene = m_networkManager.gameObject.scene;
        }

        internal void AddSpawnedNetworkObjects(ulong clientId)
        {
            m_NetworkObjectsSync.Clear();
            foreach (var sobj in m_networkManager.SpawnManager.SpawnedObjectsList)
            {
                if (sobj.Observers.Contains(clientId))
                {
                    m_NetworkObjectsSync.Add(sobj);
                }
            }

            // Sort by INetworkPrefabInstanceHandler implementation before the
            // NetworkObjects spawned by the implementation
            m_NetworkObjectsSync.Sort(SortNetworkObjects);

            // The last thing we sort is parents before children
            SortParentedNetworkObjects();
        }

        internal void AddDespawnedInSceneNetworkObjects()
        {
            m_DespawnedInSceneObjectsSync.Clear();
            // Find all active and non-active in-scene placed NetworkObjects
            var inSceneNetworkObjects = UnityEngine.Object.FindObjectsOfType<NetworkObject>(includeInactive: true).Where((c) => c.NetworkManager == m_networkManager);

            foreach (var sobj in inSceneNetworkObjects)
            {
                if (sobj.IsSceneObject.HasValue && sobj.IsSceneObject.Value && !sobj.IsSpawned)
                {
                    m_DespawnedInSceneObjectsSync.Add(sobj.GlobalObjectIdHash);
                }
            }
        }

        //被AddSpawnedNetworkObjects调用
        private int SortNetworkObjects(NetworkObject first, NetworkObject second)
        {
            var doesFirstHaveHandler = m_networkManager.PrefabHandler.ContainsHandler(first);
            var doesSecondHaveHandler = m_networkManager.PrefabHandler.ContainsHandler(second);
            if (doesFirstHaveHandler != doesSecondHaveHandler)
            {
                if (doesFirstHaveHandler)
                {
                    return 1;
                }
                else
                {
                    return -1;
                }
            }
            return 0;
        }
        //被SortParentedNetworkObjects调用
        private int SortChildrenNetworkObjects(NetworkObject first, NetworkObject second)
        {
            var firstParent = first.GetCachedParent()?.GetComponent<NetworkObject>();
            // If the second is the first's parent then move the first down
            if (firstParent != null && firstParent == second)
            {
                return 1;
            }

            var secondParent = second.GetCachedParent()?.GetComponent<NetworkObject>();
            // If the first is the second's parent then move the first up
            if (secondParent != null && secondParent == first)
            {
                return -1;
            }

            // Otherwise, don't move the first at all
            return 0;
        }

        //被AddSpawnedNetworkObjects调用
        private void SortParentedNetworkObjects()
        {
            var networkObjectList = m_NetworkObjectsSync.ToList();
            foreach (var networkObject in networkObjectList)
            {
                // Find only the root parent NetworkObjects
                if (networkObject.transform.childCount > 0 && networkObject.transform.parent == null)
                {
                    // Get all child NetworkObjects of the root
                    var childNetworkObjects = networkObject.GetComponentsInChildren<NetworkObject>().ToList();

                    childNetworkObjects.Sort(SortChildrenNetworkObjects);

                    // Remove the root from the children list
                    childNetworkObjects.Remove(networkObject);

                    // Remove the root's children from the primary list
                    foreach (var childObject in childNetworkObjects)
                    {
                        m_NetworkObjectsSync.Remove(childObject);
                    }
                    // Insert or Add the sorted children list
                    var nextIndex = m_NetworkObjectsSync.IndexOf(networkObject) + 1;
                    if (nextIndex == m_NetworkObjectsSync.Count)
                    {
                        m_NetworkObjectsSync.AddRange(childNetworkObjects);
                    }
                    else
                    {
                        m_NetworkObjectsSync.InsertRange(nextIndex, childNetworkObjects);
                    }
                }
            }
        }

        internal void OnDisconnect(ulong id)
        {
            m_ClientScenes.Remove(id);
            Debug.LogFormat("Disconnect {0}", id);
        }

        internal void OnConnect(ulong id)
        {
            m_ClientScenes.Add(id, m_DefaultScene);
            Debug.LogFormat("Connect {0}", id);
        }
        /// <summary>
        /// 这个函数在NetworkObject里的SceneChangedUpdate函数里被调用
        /// </summary>
        /// <param name="networkObject"></param>
        internal void NotifyNetworkObjectSceneChanged(NetworkObject networkObject)
        {
            if (!m_networkManager.IsServer) return;
            int scOldHandle = networkObject.SceneOriginHandle;
            int scCurHandle = networkObject.NetworkSceneHandle;
            NetworkObject.SceneObject scobj = networkObject.GetMessageSceneObject(0);

            if (!m_ObjectChangeScene.ContainsKey(scOldHandle))
            {
                SceneChangeItem item = new SceneChangeItem();
                item.sceneHandle = scOldHandle;
                item.sceneName = m_SceneHandleToName[scOldHandle];
                item.leaveQue = new Queue<NetworkObject.SceneObject>();
                item.enterQue = new Queue<NetworkObject.SceneObject>();
                item.leaveQue.Enqueue(scobj);
                m_ObjectChangeScene.Add(scOldHandle, item);
            }
            else
            {
                m_ObjectChangeScene[scOldHandle].leaveQue.Enqueue(scobj);
            }

            if (!m_ObjectChangeScene.ContainsKey(scCurHandle))
            {
                SceneChangeItem item = new SceneChangeItem();
                item.sceneHandle = scCurHandle;
                item.sceneName = m_SceneHandleToName[scCurHandle];
                item.leaveQue = new Queue<NetworkObject.SceneObject>();
                item.enterQue = new Queue<NetworkObject.SceneObject>();
                item.enterQue.Enqueue(scobj);
                m_ObjectChangeScene.Add(scCurHandle, item);
            }
            else
            {
                m_ObjectChangeScene[scCurHandle].enterQue.Enqueue(scobj);
            }

        }

        /// <summary>
        /// 这个函数在NetworkManager的NetworkUpdateStage.PostLateUpdate状态下被调用
        /// </summary>
        internal void CheckForAndSendNetworkObjectSceneChanged()
        {
            if (m_networkManager.IsServer)
            {
                //向客户端发送活动对象进出场景事件
                foreach (var clientId in m_networkManager.ConnectedClientsIds)
                {
                    int scHandle=m_SceneNameToHandle[m_ClientScenes[clientId]];
                    if (m_ObjectChangeScene.ContainsKey(scHandle))
                    {
                        if(m_ObjectChangeScene[scHandle].enterQue.Count>0|| m_ObjectChangeScene[scHandle].leaveQue.Count>0)
                        {
                            SceneEventData seData = new SceneEventData();
                            seData.seType = SceneEventType.ObjectSceneChanged;
                            seData.targetClientId = clientId;
                            seData.sceneName = m_ClientScenes[clientId];
                            seData.enterObjectCount = (ushort)m_ObjectChangeScene[scHandle].enterQue.Count;
                            seData.leaveObjectCount = (ushort)m_ObjectChangeScene[scHandle].leaveQue.Count;
                            seData.enterQue= m_ObjectChangeScene[scHandle].enterQue;
                            seData.leaveQue= m_ObjectChangeScene[scHandle].leaveQue;
                            var message = new SceneEventMessage
                            {
                                EventData = seData
                            };
                            m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);
                        }
                    }
                }
                m_ObjectChangeScene.Clear();
            }
            else
            {
                if (m_curSceneEvent != SceneEventType.Idle) return;//如果当前忙则不做处理
                //处理接收到的同步网络对象
                foreach(var obj in m_NetworkObjectsClientSync)
                {
                    //创建游戏对象并设置Spawn状态
                    //var spawnedNetworkObject = NetworkObject.AddSceneObject(obj, InternalBuffer, m_networkManager);
                    //这里需要创建一个InternalBuffer，用来传入AddSceneObject()方法。
                    //并且发现，Despawn对象也是需要同步的。
                }
                m_NetworkObjectsClientSync.Clear();

                //处理接收到的活动对象进出场景事件
                while (m_SceneChangeItem.enterQue.Count>0)
                {
                    NetworkObject.SceneObject scobj = m_SceneChangeItem.enterQue.Dequeue();
                    //创建游戏对象并设置Spawn状态
                    
                }
                while (m_SceneChangeItem.leaveQue.Count > 0)
                {
                    NetworkObject.SceneObject scobj = m_SceneChangeItem.leaveQue.Dequeue();
                    //销毁游戏对象

                }
            }
        }

        /// <summary>
        /// 这个函数在NetworkSpawnManager里的HasPrefab里被调用
        /// 这个函数在NetworkSpawnManager里的CreateLocalNetworkObject里被调用
        /// </summary>
        /// <param name="globalObjectIdHash"></param>
        /// <param name="networkSceneHandle"></param>
        /// <returns></returns>
        internal NetworkObject GetSceneRelativeInSceneNetworkObject(uint globalObjectIdHash, int? networkSceneHandle)
        {
            //因为只在客户端调用，客户端只存在一个场景，所以忽略networkSceneHandle参数
            //这个地方可以进一步性能优化
            foreach (NetworkObject no in GameObject.FindObjectsOfType<NetworkObject>())
            {
                if (no.GlobalObjectIdHash == globalObjectIdHash)
                {
                    return no;
                }
            }
            return null;
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <param name="senderId"></param>
        /// <param name="messageSize"></param>
        /// <param name="sceneObject"></param>
        /// <param name="fastBufferReader"></param>
        internal void DeferCreateObject(ulong senderId, uint messageSize, NetworkObject.SceneObject sceneObject, FastBufferReader fastBufferReader)
        {

        }

        /// <summary>
        /// 这个函数在NetworkCoonnectionManager的HandleConnectionApproval函数里被调用
        /// </summary>
        /// <param name="clientId"></param>
        internal void SynchronizeNetworkObjects(ulong clientId)
        {
            //更新和触发OnConnect事件
            if (!m_networkManager.ConnectedClients[clientId].IsConnected)
            {
                m_networkManager.ConnectedClients[clientId].IsConnected = true;
                m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(clientId);
            }

            //同步场景和场景内的静态网络对象
            SceneEventData seData = new SceneEventData();
            seData.seType = SceneEventType.ClientSceneLoad;
            seData.targetClientId = clientId;
            seData.sceneName = m_ClientScenes[clientId];
            var message = new SceneEventMessage
            {
                EventData = seData
            };
            m_networkManager.ConnectionManager.SendMessage(ref message, NetworkDelivery.ReliableFragmentedSequenced, clientId);

            //同步动态生成的网络对象
            //更新客户端可见性
            m_networkManager.SpawnManager.UpdateObservedNetworkObjects(clientId);
            //生成需要同步的网络对象列表
            AddSpawnedNetworkObjects(clientId);
            AddDespawnedInSceneNetworkObjects();
            //发送消息同步网络对象
            SceneEventData seData1 = new SceneEventData();
            seData1.seType = SceneEventType.Synchronize;
            seData1.targetClientId = clientId;
            seData1.sceneName = m_ClientScenes[clientId];
            seData1.networkObjectsSync = new List<NetworkObject>();
            foreach (var obj in m_NetworkObjectsSync)
                seData1.networkObjectsSync.Add(obj);
            seData1.despawnedInSceneObjectsSync = new List<uint>();
            foreach (var obj in m_DespawnedInSceneObjectsSync)
                seData1.despawnedInSceneObjectsSync.Add(obj);
            var message1 = new SceneEventMessage
            {
                EventData = seData1
            };
            m_networkManager.ConnectionManager.SendMessage(ref message1, NetworkDelivery.ReliableFragmentedSequenced, clientId);
        }

        /// <summary>
        /// 这个函数在CreateObjectMessage里的Handle函数里被调用
        /// </summary>
        /// <returns></returns>
        internal bool ShouldDeferCreateObject()
        {
            return false;
        }

        /// <summary>
        /// 客户端网络消息处理函数
        /// </summary>
        /// <param name="seData"></param>
        internal void HandleSceneEvent(SceneEventData seData)
        {
            if (m_networkManager.IsServer)
            {

            }
            else
            {
                if (seData.seType == SceneEventType.ClientSceneLoad)
                {
                    if (!m_networkManager.IsConnectedClient)
                    {
                        m_networkManager.IsConnectedClient = true;
                        m_networkManager.ConnectionManager.InvokeOnClientConnectedCallback(m_networkManager.LocalClientId);
                    }
                    IsSpawnedObjectsPendingInDontDestroyOnLoad = true;
                    m_SceneEventData = seData;
                    m_SceneEventDataClientSceneLoad = seData;
                    m_curLoadScene = seData.sceneName;
                    AsyncOperation op = SceneManager.LoadSceneAsync(m_curLoadScene, LoadSceneMode.Single);
                    op.completed += OnClientSceneLoadComplete;
                }

                if(seData.seType == SceneEventType.ObjectSceneChanged)
                {
                    if(seData.sceneName!=m_SceneChangeItem.sceneName)
                    {
                        m_SceneChangeItem.sceneName = seData.sceneName;
                        m_SceneChangeItem.enterQue.Clear();
                        m_SceneChangeItem.leaveQue.Clear();
                    }
                    foreach(var q in seData.enterQue)
                        m_SceneChangeItem.enterQue.Enqueue(q);
                    foreach(var q in seData.leaveQue)
                        m_SceneChangeItem.leaveQue.Enqueue(q);
                }

                if(seData.seType == SceneEventType.Synchronize)
                {
                    //暂时不处理
                }
            }
        }

        private void OnClientSceneLoadComplete(AsyncOperation op)
        {
            //此处的代码存在bug，没有将NetworkBehaviour的数据考虑进去。应该使用NetworkObject.AddSceneObject来进行NetworkBehaviour的解包。
            //此处还应该将despawn的insceneobject也包含进来。
            ushort sceneObjectCount;
            m_SceneEventDataClientSceneLoad.InternalBuffer.ReadValueSafe(out sceneObjectCount);
            List<NetworkObject>  sceneObjects = new List<NetworkObject>();

            for (int i = 0; i < sceneObjectCount; i++)
            {
                NetworkObject.SceneObject obj = new NetworkObject.SceneObject();
                obj.Deserialize(m_SceneEventDataClientSceneLoad.InternalBuffer);
                var networkObject = NetworkObject.AddSceneObject(obj, m_SceneEventDataClientSceneLoad.InternalBuffer, m_networkManager);
                sceneObjects.Add(networkObject);
            }

            foreach (var networkObject in sceneObjects)
            {
                networkObject.InternalInSceneNetworkObjectsSpawned();
            }

            Scene sc = SceneManager.GetSceneByName(m_curLoadScene);
            MoveObjectsFromDontDestroyOnLoadToScene(sc);
            IsSpawnedObjectsPendingInDontDestroyOnLoad = false;

            if (m_curSceneEvent== SceneEventType.ClientSceneLoad)
                m_curSceneEvent = SceneEventType.Idle;
        }

        internal void MoveObjectsFromDontDestroyOnLoadToScene(Scene scene)
        {
            foreach (var networkObject in m_networkManager.SpawnManager.SpawnedObjectsList)
            {
                if (networkObject == null)
                {
                    continue;
                }
                // If it is in the DDOL then
                if (networkObject.gameObject.scene == DontDestroyOnLoadScene && !networkObject.DestroyWithScene)
                {
                    // only move dynamically spawned network objects, with no parent as child objects will follow,
                    // back into the currently active scene
                    if (networkObject.gameObject.transform.parent == null && networkObject.IsSceneObject != null && !networkObject.IsSceneObject.Value)
                    {
                        SceneManager.MoveGameObjectToScene(networkObject.gameObject, scene);
                    }
                }
            }
        }

        public void Dispose()
        {
            m_networkManager.OnClientDisconnectCallback -= OnDisconnect;
            m_networkManager.OnClientConnectedCallback -= OnConnect;
        }

        public bool IsIdle()
        {
            return (m_curSceneEvent == SceneEventType.Idle && m_sceneEvent.Count == 0);
        }

        public void SvrLoadScene(string sceneName)
        {
            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.IsForLoad = true;
            ssEvent.sceneName = sceneName;
            m_sceneEvent.Enqueue(ssEvent);
            if (m_sceneEvent.Count > 1) return;
            ProcessServerSceneEvent();
        }

        public void SvrUnloadScene(string sceneName)
        {
            ServerSceneEvent ssEvent = new ServerSceneEvent();
            ssEvent.IsForLoad = false;
            ssEvent.sceneName = sceneName;
            m_sceneEvent.Enqueue(ssEvent);
            if (m_sceneEvent.Count > 1) return;
            ProcessServerSceneEvent();
        }

        public void SvrCreateAndMerageScene(string desScene, string srcScene, Vector3 offset)
        {

        }

        public void ClientSwitchScene(string curScene)
        {

        }

        public void SetDefaultScene(string defaultScene)
        {
            m_DefaultScene = defaultScene;
        }
        
        private void OnProcessServerSceneEventEnd()
        {
            m_SceneHandleToName.Clear();
            m_SceneNameToHandle.Clear();
            //生成句柄和场景名称的映射字典
            m_SceneHandleToName.Add(DontDestroyOnLoadScene.handle, DontDestroyOnLoadScene.name);
            m_SceneNameToHandle.Add(DontDestroyOnLoadScene.name,DontDestroyOnLoadScene.handle);
            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene sc = SceneManager.GetSceneAt(i);
                m_SceneHandleToName.Add(sc.handle, sc.name);
                m_SceneNameToHandle.Add(sc.name,sc.handle);
                Debug.LogFormat("scname:{0} schandle:{1}", sc.name, sc.handle);
            }
        }

        private void ProcessServerSceneEvent()
        {
            if (m_sceneEvent.Count == 0)
            {
                m_curSceneEvent = SceneEventType.Idle;
                OnProcessServerSceneEventEnd();
                return;
            }

            if (m_curSceneEvent != SceneEventType.Idle)
                return;

            
            bool bFailed;
            do
            {
                ServerSceneEvent ssEvent = m_sceneEvent.Peek();
                bFailed = false;
                if (ssEvent.IsForLoad)
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneLoad;
                        m_curLoadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.LoadSceneAsync(ssEvent.sceneName, LoadSceneMode.Additive);
                        op.completed += OnSvrSceneLoadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("LoadScene {0} Exception caught: {1}", m_curLoadScene,e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
                else
                {
                    try
                    {
                        m_curSceneEvent = SceneEventType.SvrSceneUnload;
                        m_curLoadScene = ssEvent.sceneName;
                        AsyncOperation op = SceneManager.UnloadSceneAsync(ssEvent.sceneName, UnloadSceneOptions.None);
                        op.completed += OnSvrSceneUnloadComplete;
                        return;
                    }
                    catch (SystemException e)
                    {
                        Debug.Log(string.Format("UnloadScene {0} Exception caught: {1}", m_curLoadScene,e.Message));
                        bFailed = true;
                        m_sceneEvent.Dequeue();
                    }
                }
            } while (bFailed&& m_sceneEvent.Count>0);

           m_curSceneEvent = SceneEventType.Idle;
           OnProcessServerSceneEventEnd();
           return;
        }

        private void OnSvrSceneUnloadComplete(AsyncOperation op)
        {
            m_sceneEvent.Dequeue();

            Debug.LogFormat("Unload scene {0} Completed", m_curUnloadScene);
            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneEvent();
        }

        private void OnSvrSceneLoadComplete(AsyncOperation op)
        {
            m_sceneEvent.Dequeue();

            Debug.LogFormat("load scene {0} Completed", m_curLoadScene);
            int c = SvrSpawnSceneObjects(m_curLoadScene);
            Debug.LogFormat("spawn scene {0} Completed, {1} SceneObject Spawned", m_curLoadScene, c);
            m_curSceneEvent = SceneEventType.Idle;
            ProcessServerSceneEvent();
        }

        private int SvrSpawnSceneObjects(string sceneName)
        {
            int count = 0;
            Scene sc = SceneManager.GetSceneByName(sceneName);
            if (sc == null || !sc.IsValid()) return count;
            
            GameObject[] gameObjects = sc.GetRootGameObjects();
            foreach(var go in gameObjects)
            {
                NetworkObject[] objs=go.GetComponentsInChildren<NetworkObject>(true);
                foreach( var netobj in objs)
                {
                    if (!netobj.IsPlayerObject && (netobj.IsSceneObject == null||netobj.IsSceneObject==true))
                    {
                        m_networkManager.SpawnManager.SpawnNetworkObjectLocally(netobj, m_networkManager.SpawnManager.GetNetworkObjectId(), true, false, NetworkManager.ServerClientId, true);
                        netobj.InternalInSceneNetworkObjectsSpawned();
                        count++;
                    }
                }
            }

            return count;
        }
    }
}